<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七喜先生の猫</title>
  
  <subtitle>起风了，唯有努力生存</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuanpei.github.io/"/>
  <updated>2019-05-10T10:39:36.423Z</updated>
  <id>https://qinyuanpei.github.io/</id>
  
  <author>
    <name>七喜先生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>又见AOP之基于RealProxy实现WCF动态代理</title>
    <link href="https://qinyuanpei.github.io/posts/2954591764/"/>
    <id>https://qinyuanpei.github.io/posts/2954591764/</id>
    <published>2019-05-10T16:27:50.000Z</published>
    <updated>2019-05-10T10:39:36.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近一直在研究Mongodb和ElasticSearch之间同步数据的问题，苦于到目前为止，并没有取得任何实质性的进展。偶尔“趁得浮生半日闲暇”，看一看Web API设计方面的书籍，和前辈交流下项目中的历史遗留问题，最为直观的感受就是，这个世界上任何方案的最终落地，都经过理想和现实的无数次挣扎，比如我们希望迁移项目到.NET Core平台上，初步分析大概有将近1000多个无法兼容的地方，维持现状固然可以保证整个项目的稳定，可如果真到了不得不升级的地步，面临的问题可能会越来越多，所谓“凡事预则立，不预则废”，早一点准备总是好的。既然说到里历史问题，那么，今天这篇文章就来说一说，基于RealProxy实现WCF动态代理。</p><h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>在我们的业务系统中，对内是使用WCF来进行相互通信的，而对外则是使用Web API来进行数据交换。关于RPC还是REST的争论由来已有，严格地来说，两者没有绝对的高下之分，从风格上而言，RPC倾向于让接口映射到一个方法上，而REST则倾向于让接口映射到一个资源上。从我们实际的使用情况来看，REST在系统中应用得并不是很完美，因为大多数情况下，我们实现的仅仅是HTTP+JSON这样一种协议组合，因此业务系统中存在着大量的WCF接口供系统内部调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2wasftjc2j20dl0b6t8z.jpg" alt="内部服务调用示意图" title>                </div>                <div class="image-caption">内部服务调用示意图</div>            </figure><p>最早的时候，是通过T4模板来生成针对某个接口的代理类，而代理类中通常封装了ChannelFactory的创建、释放等等WCF相关的代码，实际应用中还会对WCF接口的异常进行捕获、记录日志、统计调用时间等，因此早期的T4模板实际上承担了生成代理类的职责。虽然业务的不断推进，接口中加入的新方法越来越多，导致具体业务类中的代码越来越多，动辄出现单个文件中代码行数达3000行以上，与此同时，每当WCF接口中增加了新方法，就不得不在其相关的代理类中增加代理方法。坦白地讲，就是增加一个看起来差不多的方法，因为你依然要处理ChannelFactory的创建、释放、异常处理、日志记录等等的工作。</p><p>其实，WCF可以直接生成客户端代码，因为每个WCF的服务都可以以WebService服务的形式暴露出来，而只要是WebService，总可以通过WSDL生成一个代理类。不过这显然不利于团队间的协作，更不利于服务终结点配置的集中化，更失去了异常处理、日志记录等等这些“通用”工作的可能性。T4应该可以基于“工作”，可显然大家觉得手写比生成要来得更容易些，所以，这个故事最终演变成这样一个局面，我们不得不通过局部类(Partial Class)的方式来开辟新的类文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2wad7ddv6j20tn09bt9o.jpg" alt="系统中充斥着大量类似的代码" title>                </div>                <div class="image-caption">系统中充斥着大量类似的代码</div>            </figure><p>那么，说了这么多，从一个历史遗留问题入手，它真正的痛点在哪里呢？在我看来，主要有两点：第一，是手写代理类的“此恨绵绵无绝期”，明明就是对接口的简单封装，看起来是增加一个代理方法，其实最多就是复制黏贴，因为代理方法的核心代码就是调用接口，而剩下的都是重复的“服务型”代码；第二，是异常处理、日志记录的“哀鸿遍野”，同核心代码交织在一起，一遍又一遍的“重复”，为什么不考虑让它统一地去处理呢？难道每个人都抄着同一段代码，这样就实现了某种意义上的复用吗？</p><h1 id="RealProxy介绍"><a href="#RealProxy介绍" class="headerlink" title="RealProxy介绍"></a>RealProxy介绍</h1><p>既然像我这样懒惰的人，不愿意像别人一样手写代理类，那么我的思路又是什么呢？显然，从这篇文章的题目，你就可以看出，我这里要说的是动态代理，原来的代理类同样属于代理，它是在编译时期间生成了一个代理类，我们以为在调用这个代理类，可其实真正去工作的是ChannelFactory，这种方式称之为“静态代理”。如果你了解过设计模式，应该会知道相对应的代理模式，这里不再展开开来讲这这个设计模式，可以明确的是，动态代理就是在运行时期间动态创建一个代理对象的实例，它可以完全模拟被代理对象的行为，而我们的目的，就是要和手写的代理类永远地说再见！</p><p>好了，下面隆重介绍本文的主角——RealProxy。相信大家一定听说过AOP，即所谓的面向切面编程。它可以让我们在某一个所针对的横切面编程，并讲这种功能应用到所有相同的横切面上。譬如对方法级别的横切面增加拦截器，那么所有的方法都可以在执行前后具备相同的逻辑，典型的如日志记录、指定操作前的检验等等。而RealProxy 类恰恰提供最基本的代理功能，它是一个抽象类，必须通过重写其 Invoke()方法并添加新功能来继承，该类位于System.Runtime.Remoting.Proxies 命名空间中，通过重写Invoke()方法，我们就可以在被代理对象调用前后插入相关逻辑，而通过GetTransparentProxy()方法，则可以返回实际的代理对象。所以，通过这个原理，我们就可以在运行时期间，动态创建出指定类型的实例。这里，我们从一个简单的例子来开始，以帮助大家更好的理解RealProxy。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICalculator</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Add</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Subtract</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Multiply</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorService</span> : <span class="title">ICalculator</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Add</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Subtract</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Multiply</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">return</span> n1 * n2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">double</span> n1, <span class="keyword">double</span> n2</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">return</span> n1 / n2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先，我们定义一个简单的接口ICalculator，它含有加、减、乘、除四种基本运算，我们希望记录每个方法调用的参数、结果和执行时间，因此通过RealProxy对现有类型CalculatorService进行代理，并动态地创建代理对象来供调用方使用，下面给出关键代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorServiceProxy</span> : <span class="title">RealProxy</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> Server.Service.ICalculator _calculator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CalculatorServiceProxy</span>(<span class="params">Server.Service.ICalculator calculator</span>) :</span></span><br><span class="line"><span class="function">            <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(Server.Service.ICalculator</span>))</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            _calculator = calculator;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IMessage <span class="title">Invoke</span>(<span class="params">IMessage message</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">var</span> methodCall = message <span class="keyword">as</span> IMethodCallMessage;</span><br><span class="line">            <span class="keyword">var</span> methodInfo = methodCall.MethodBase <span class="keyword">as</span> MethodInfo;</span><br><span class="line">            <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> serviceName = _calculator.GetType().Name;</span><br><span class="line">            <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"调用{0}服务的{1}方法开始..."</span>, serviceName, methodName);</span><br><span class="line">                <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary<<span class="keyword">string</span>, <span class="keyword">object</span>>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < methodCall.ArgCount; i++)</span><br><span class="line">                {</span><br><span class="line">                    argsInfo.Add(methodCall.GetArgName(i), methodCall.Args[i]);</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine(<span class="string">"当前传入参数:{0}"</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">                <span class="keyword">var</span> result = methodInfo.Invoke(_calculator, methodCall.InArgs);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                    Console.WriteLine(<span class="string">"当前返回值:{0}"</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnMessage(result, <span class="literal">null</span>, <span class="number">0</span>, methodCall.LogicalCallContext, methodCall);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"调用{0}服务的{1}方法失败,失败原因：{2}"</span>, serviceName, methodName, ex.Message);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"调用{0}服务的{1}方法结束,共耗时{2}秒"</span>, serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds);</span><br><span class="line">                Console.WriteLine(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以注意到，最核心的代码是在Invoke()方法中，在这里我们增加了我们想要的功能，但这些功能丝毫不会影响到CalculatorService，当我们通过构造函数给RealProxy传入被代理对象后，它就会对被代理对象的特定方法进行拦截，这里实际上就是加、减、乘、除四个方法。OK，到现在为止，这些都是我们的想像而已，具体我们实现执行结果来看。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceProxy = <span class="keyword">new</span> CalculatorServiceProxy(<span class="keyword">new</span> CalculatorService());</span><br><span class="line"><span class="keyword">var</span> calculator = (ICalculator)serviceProxy.GetTransparentProxy();</span><br><span class="line">calculator.Add(<span class="number">12</span>, <span class="number">24</span>);</span><br><span class="line">calculator.Subtract(<span class="number">36</span>, <span class="number">10</span>);</span><br><span class="line">calculator.Multiply(<span class="number">12</span>, <span class="number">35</span>);</span><br><span class="line">calculator.Divide(<span class="number">36</span>, <span class="number">12</span>);</span><br></pre></td></tr></tbody></table></figure><p>现在，我们可以说，刚刚所说的一切都是真的，因为我们真的创建了一个ICalculator接口的实例，它真的记录了每个方法调用的参数、结果和执行时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2w7brst4dj20rm0eqgmc.jpg" alt="RealPrxoy牛刀小试" title>                </div>                <div class="image-caption">RealPrxoy牛刀小试</div>            </figure><h1 id="WCF动态代理"><a href="#WCF动态代理" class="headerlink" title="WCF动态代理"></a>WCF动态代理</h1><p>现在，我们来考虑WCF，WCF需要通过ChannelFactory来创建和释放，而这恰恰是代理类所做的事情，就像下面的代码一样，我们通常会把所有的WCF集中配置在一个地方，并通过构造Binding和终结点地址来创建一个WCF服务，在调用服务的过程中，会对调用时间、异常信息等进行记录，这其实和我举的第一个例子完全一致，那么我们能不能用RealProxy来实现这些功能呢？</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ServiceInfo<TService></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ChannelFactory _channelFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceInfo</span>(<span class="params">ChannelFactory channelFactory</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        _channelFactory = channelFactory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TService Service { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">if</span> (_channelFactory != <span class="literal">null</span>)</span><br><span class="line">            _channelFactory.Close();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo<TService> <span class="title">FindService</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ChannelFactory<TService> channelFactory = <span class="keyword">new</span> ChannelFactory<TService>(_binding, _endpointAddress);</span><br><span class="line">    <span class="keyword">var</span> serviceInfo = <span class="keyword">new</span> ServiceInfo<TService>(channelFactory);</span><br><span class="line">    serviceInfo.Service = channelFactory.CreateChannel();</span><br><span class="line">    <span class="keyword">return</span> serviceInfo;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>顺着这样的思路，如果我们可以把ChannelFactory注入到RealProxy中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的WCF服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicServiceProxy<TService> : RealProxy</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Binding _binding;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EndpointAddress _endpointAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicServiceProxy</span>(<span class="params">Binding binding, EndpointAddress endpointAddress</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(TService</span>))</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        _binding = binding;</span><br><span class="line">        _endpointAddress = endpointAddress;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicServiceProxy</span>(<span class="params">Binding binding, <span class="keyword">string</span> serviceUrl</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params">binding, new EndpointAddress(serviceUrl</span>))</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IMessage <span class="title">Invoke</span>(<span class="params">IMessage message</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> serviceInfo = FindService();</span><br><span class="line">        <span class="keyword">var</span> methodCall = message <span class="keyword">as</span> IMethodCallMessage;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = methodCall.MethodBase <span class="keyword">as</span> MethodInfo;</span><br><span class="line">        <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">        <span class="keyword">var</span> serviceName = serviceInfo.Service.GetType().Name;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"RealProxy调用{0}服务{1}方法开始..."</span>, serviceName, methodName);</span><br><span class="line">            <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary<<span class="keyword">string</span>, <span class="keyword">object</span>>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < methodCall.ArgCount; i++)</span><br><span class="line">            {</span><br><span class="line">                argsInfo.Add(methodCall.GetArgName(i), methodCall.Args[i]);</span><br><span class="line">            }</span><br><span class="line">            Console.WriteLine(<span class="string">"RealProxy当前传入参数:{0}"</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">            <span class="keyword">var</span> result = methodInfo.Invoke(serviceInfo.Service, methodCall.InArgs);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                Console.WriteLine(<span class="string">"RealProxy当前返回值:{0}"</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnMessage(result, <span class="literal">null</span>, <span class="number">0</span>, methodCall.LogicalCallContext, methodCall);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"RealProxy调用{0}服务{1}方法失败,失败原因：{2}"</span>, serviceName, methodName, ex.Message);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        {</span><br><span class="line">            serviceInfo.Close();</span><br><span class="line">            Console.WriteLine(<span class="string">"调用{0}服务{1}方法结束,共耗时{2}秒"</span>, serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds);</span><br><span class="line">            Console.WriteLine(<span class="string">"----------------------------------"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于WCF服务端的实现，我们依然使用ICalculator这个接口，需要注意的是为其添加[ServiceContract]和[OperationContract]标签，在这个例子中，我们共有CalculatorService和MessageService两个服务，为了简化这个实例，我们采用BasicHttpBinding的方式进行绑定，并为其指定各自的终结点地址。可以注意到，现在我们的动态代理实现了和原来代理类一样的效果。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binding = <span class="keyword">new</span> BasicHttpBinding();</span><br><span class="line"><span class="keyword">var</span> serviceUrl = <span class="string">"http://localhost:8502/Calculator.svc"</span>;</span><br><span class="line"><span class="keyword">var</span> calculator = ServiceProxyFactory.CreatePorxy<Server.Service.ICalculator>(binding, serviceUrl);</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2w85svbrfj20rp0eqq41.jpg" alt="通过RealPrxoy动态代理WCF服务" title>                </div>                <div class="image-caption">通过RealPrxoy动态代理WCF服务</div>            </figure><p>在调用WCF的时候，因为超时、网络等原因造成的调用异常，此时，我们可以为WCF添加异常处理相关的标签，而相应地，我们可以在异常中对异常的种类进行判断和处理，以便于及时地关闭ChannelFactory，因为如果它不能正确地关闭，会导致后续的通信出现问题，而这恰好是当初的代理类想要解决的问题，考虑到创建ChannelFactory是需要付出一定的性能代价的，因此，可以适当地考虑对ChannelFactory进行缓存，而这恰好是原来业务中的一个盲点。</p><h1 id="Castle-DynamicProxy"><a href="#Castle-DynamicProxy" class="headerlink" title="Castle.DynamicProxy"></a>Castle.DynamicProxy</h1><p>通过RealProxy，我们已经实现了WCF服务的动态代理，这里介绍第二种方式，即Castle.DynamicProxy，Castle和AspectCore、Unity等项目一样，提供了AOP相关的能力，可以让我们对接口、虚方法、类等进行拦截。Castle中的动态代理使用的是透明代理，而.NET Remoting的动态代理必须继承自MarshalByRefObject。博主暂时没有搞清楚，这两种是否属于同一种技术上的实现，作为延伸，我们来一起看看如何使用Castle中的DynamicProxy实现类似的功能，首先我们定义一个拦截器，它需要实现IInterceptor接口中的Intercept()方法：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">var</span> serviceInfo = FindService();</span><br><span class="line">    <span class="keyword">var</span> methodInfo = invocation.Method;</span><br><span class="line">    <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">    <span class="keyword">var</span> serviceName = serviceInfo.Service.GetType().Name;</span><br><span class="line">    <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"CastleProxy调用{0}服务{1}方法开始..."</span>, serviceName, methodName);</span><br><span class="line">        <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary<<span class="keyword">string</span>, <span class="keyword">object</span>>();</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < invocation.Arguments.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            argsInfo.Add(parameters[i].Name, invocation.Arguments[i]);</span><br><span class="line">        }</span><br><span class="line">        Console.WriteLine(<span class="string">"当前传入参数:{0}"</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">        <span class="keyword">var</span> result = methodInfo.Invoke(serviceInfo.Service, invocation.Arguments);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) { </span><br><span class="line">        Console.WriteLine(<span class="string">"当前返回值:{0}"</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">            invocation.ReturnValue = result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"CastleProxy调用{0}服务{1}方法失败,失败原因：{2}"</span>, serviceName, methodName, ex.Message);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    {</span><br><span class="line">        serviceInfo.Close();</span><br><span class="line">        Console.WriteLine(<span class="string">"CastleProxy调用{0}服务{1}方法结束,共耗时{2}秒"</span>, serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds);</span><br><span class="line">        Console.WriteLine(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们通过ProxyGenerator来生成新的代理类，我们需要告诉ProxyGenerator要创建的类型是什么，是一个接口还是类，以及要应用哪一个拦截器。这里我们用到的方法是CreateInterfaceWithoutTarget()，它在这里的作用就是动态创建ICalculator接口的代理类。而通过查看Castle的API，我们会发现它可以在以下几种情况下创建某个类型的实例。首先是CreateInterfaceWithoutTarget()这个方法，当你希望创建一个接口的代理而又不想提供具体的实现时可以使用。其次是CreateInterfaceProxyWithTarget()这个方法，当你希望创建一个接口的代理同时又有提供具体实现时使用可以使用。接下来，是CreateInterfaceProxyWithTargetInterface()这个方法，它的命名看起来让人感到迷惑，甚至在某种角度来看，它和CreateInterfaceProxyWithTarget()这个方法还有点相似，其实。这两者最大的不同就是：后者允许你将调用目标替换为目标接口的不同实现。这种在实际场景中使用得不多，从Castle官方的使用场景来看，唯一用到这种技术的是Castle.Facilities，它可以和Windsor 这样的容器整合在一起使用，这个时候调用者就可以把WCF服务当作一个普通接口来使用，果然，大家都想到这一点，英雄所见略同啊，哈哈。好了，下面我们来看具体的代码实现：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProxyGenerator generator = <span class="keyword">new</span> ProxyGenerator();</span><br><span class="line"><span class="keyword">var</span> interceptor = <span class="keyword">new</span> CastleServicePorxy<ICalculator>(binding, serviceUrl);</span><br><span class="line"><span class="keyword">var</span> calculator = (ICalculator)generator.CreateInterfaceProxyWithoutTarget(<span class="keyword">typeof</span>(ICalculator),interceptor);</span><br></pre></td></tr></tbody></table></figure><h1 id="迁移至-NET-Core"><a href="#迁移至-NET-Core" class="headerlink" title="迁移至.NET Core"></a>迁移至.NET Core</h1><p>其实，我对WCF是不太感冒的，因为第一个字母W表明，它是一个只能运行在Windows平台的产物，现在依然有大量的Web Service存在，如果可以让我像使用普通接口一样使用WCF接口，我还是非常愿意去使用它的，毕竟系统中有大量依赖WCF的东西。可话又说回来，现在到.NET Core这个版本，微软并没有把WCF的服务端移植到.NET Core上，仅仅是提供了客户端调用的支持，或许还是因为WCF里有太多平台相关的东西吧！如果希望自己的.NET应用可以跨平台，越早摆脱这些Windows平台东西越好，譬如IIS、SQLServer等等。不过我这里想说的是，RealProxy在.NET Core中有类似的实现，我们可以用下面这种方式来进行迁移，当然，如果你直接Castle就更没有问题啦！</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvokeSerice</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Proxy<T>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> DispatchProxy.Create<T, InvokeProxy<T>>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class InvokeProxy<T> : DispatchProxy</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> Type type = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokeProxy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        type = <span class="keyword">typeof</span>(T);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">object</span> <span class="title">Invoke</span>(<span class="params">MethodInfo targetMethod, <span class="keyword">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 在这里实现拦截逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客再次让大家领略了AOP的魅力，通过动态代理来创建相关的服务接口，让我们逐渐摆脱了手写代理类的深渊。本文主要分享了两种动态代理的实现方式，一种是基于.NET Remoting的RealProxy，一种是基于Castle的DynamicProxy。两种方式在使用上是非常相近的，通过这种方式。我们实现了WCF服务创建细节的隐藏，调用者不再需要去关心ChannelFactory相关的底层细节，可以像使用普通接口一样调用WCF服务，并且可以用一种统一的方式去记录调用相关的细节、对异常进行处理等等。早期的T4模板本质上是一种静态代理的方式，其缺点是难以适应快速迭代的变化，必须人手编写代理方法，而通过动态代理，这一切只需要写一次就好了，从而做到了真正意义上的“一次编写，到处运行”，这就是所谓的面向横切面编程的思路。关于Castle动态代理更多的应用场景，以及Castle.Facilities相关的内容，大家可以从各自的文档中去了解，以上就是这篇博客的全部内容了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="Castle" scheme="https://qinyuanpei.github.io/tags/Castle/"/>
    
      <category term="Dynamic Proxy" scheme="https://qinyuanpei.github.io/tags/Dynamic-Proxy/"/>
    
  </entry>
  
  <entry>
    <title>WSL下Docker使用踩坑小记</title>
    <link href="https://qinyuanpei.github.io/posts/4159187524/"/>
    <id>https://qinyuanpei.github.io/posts/4159187524/</id>
    <published>2019-04-22T22:13:36.000Z</published>
    <updated>2019-05-10T10:39:36.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>众所周知，Win10中开始提供Linux子系统，即Windows Subsystem for Linux，简称WSL，它可以让我们在Windows系统使用Linux系统，自从有了这个新功能以后，博主果断地放弃双系统的方案，因为折腾起来实在花费时间。关于如何使用WSL，网上有非常多的文章可以参考，这里不再赘述。今天想说的是，WSL下使用Docker遇到的各种坑。</p><p>装完WSL以后，对各种编译环境的使用相当满意，最近在研究日志可视化平台ELK，其中需要使用Docker来搭建环境，一顿sudo操作猛如虎，快速安装完Docker环境，结果发现熟悉的命令行居然无法正常工作，是可忍孰不可忍。<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta">   $</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">   stable"</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></tbody></table></figure><p></p><p>第一个错误是，你按照官方文档安装完Docker，输入docker -v，一切显示正常的时候，此时，如果会执行docker run hello-world命令，会出现以下错误：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?. See <span class="string">'docker run --help'</span>.</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>此时，你可能会尝试通过执行systemctl start docker命令来启动Docker服务，因为错误信息告诉我们，Docker的守护进程没有启动，可你会发现这样依然报错。可是为什么呢？明明Docker都在WSL里安装成功了啊，事实上除了docker -v不需要依赖守护进程，其余的命令都需要依赖守护进程，而WSL恰恰是不支持docker-engine的，所以，一种曲线救国的思路就是，让WSL去连接宿主机上的docker engine。果然，还是要安装Docker for Windows啊！那么，剩下的事情变得就非常简单啦，确保系统开启Hyper-V，然后安装Docker for Windows，并打开对宿主机Docker的监听，这些相信玩过Docker的人都会啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2oho3u2jcj20m80f8757.jpg" alt="暴露宿主机器Docker端口" title>                </div>                <div class="image-caption">暴露宿主机器Docker端口</div>            </figure><p>接下来，我们给WSL中的Docker设置宿主机的地址，在终端中输入下列命令即可：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=tcp://localhost:2375</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时，我们执行docker run hello-world命令，如果不出意外的话，我们会看到下面的画面，这说明我们的Docker环境已经正常工作啦：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2ohrctulqj20m80bomy1.jpg" alt="WSL中完美运行的Docker" title>                </div>                <div class="image-caption">WSL中完美运行的Docker</div>            </figure><p>博主按捺不住内心的激动，果断安装ELK全家桶，体验了下Kibana的可视化界面，开始思考：如何把存储在Mongodb中的日志数据放到ElasticSearch中。当然，这都是后话啦，因为博主马上发现了WSL中Docker的第二个坑，那就是终端关闭以后，针对宿主机的Docker连接就结束了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g2oht8m7jnj20m80badgj.jpg" alt="ELK全家桶" title>                </div>                <div class="image-caption">ELK全家桶</div>            </figure><p>OK，为了解决这个问题，我们继续在终端中输入以下命令：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "export DOCKER_HOST=tcp://localhost:2375" >> ~/.bashrc && source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure><p></p><p>在使用Docker的过程中，最令人困惑的部分当属分区的挂载，因为你时刻要搞清楚，它到底表示的是容器内部的分区，还是宿主机上的分区。对于运行在WSL中的Docker而言，它会采用类似/mnt/c/Users/Payne/<your-app>这样的更符合Linux习惯的路径，而Docker for Windows则会使用类似/c/Users/Payne/<your-app>这样更符合Windows习惯的路径。因此，如果你在使用Docker的过程中，需要处理分区挂载相关的东西，一个比较好的建议是修改WSL的配置文件(如果不存在需要自行创建)：<br></your-app></your-app></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wsl.conf</span><br><span class="line">[automount]</span><br><span class="line">root = /</span><br><span class="line">options = "metadata"</span><br></pre></td></tr></tbody></table></figure><p></p><p>好了，以上就是在使用WSL中的Docker搭建ELK全家桶过程中遇到的问题的梳理，从体验上来讲，我个人会把Linux平台相关的工作渐渐转移到WSL上，因为安装双系统总会分散你的精力去处理维护相关的事情，虽然装系统对程序员来说都不算是个事儿，可我内心依旧排斥自己被贴上“修电脑”的标签。我会在后续的博客中分享.NET Core下日志分析平台构建相关内容，希望大家可以继续关注我的博客，这篇文章到此结束，谢谢大家！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="WSL" scheme="https://qinyuanpei.github.io/tags/WSL/"/>
    
      <category term="Docker" scheme="https://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="https://qinyuanpei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>由DBeaver与PL/SQL引发的数据库吐槽</title>
    <link href="https://qinyuanpei.github.io/posts/337943766/"/>
    <id>https://qinyuanpei.github.io/posts/337943766/</id>
    <published>2019-04-19T12:52:10.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>因为工作中需要同时面向MySQL、Oracle和SQLServer三种数据库进行开发，所以，大概从去年国庆节开始，我开始使用一个开源的数据库管理工具——DBeaver。</p><p>使用这个工具的初衷，是因为我不想在同一台电脑上安装三个客户端工具，尤其是Oracle和SQLServer这种令人恐惧的、动辄需要重装系统的应用程序。我不想再使用类似Navicat这样的软件，因为它的画风像是上个世纪VB6.0的产品一样，同理，我不喜欢用PL/SQL，因为我每次都要瞪大眼睛，在它狭窄而拥挤的画面上找表、找视图，更有甚者，有时要去找触发器、找存储过程。直到我同事给我发了一个几十M的文档，我突然间意识到，这货居然还要安装Oracle的客户端，配置数据库连接要手动去改配置文件，我一点都不喜欢PL/SQL。</p><p>除了这三种经典的关系型数据库，我们还会用Memcache和Redis这样的内存数据库，Mongodb这样的非关系型数据库，所以，我希望有一个统一的入口来管理这些连接，毕竟我身边的同事会使用三种以上的工具，譬如<strong>Sqlyog</strong>、<strong>PL/SQL</strong>、<strong>SQLServer</strong>等来处理这些工作，恰好DBeaver可以满足我80%的工作需要。目前，DBeaver企业版支持关系型数据库和非关系型数据库，而社区版仅支持关系型数据库。</p><p>可最近在写Oracle环境的触发器(<strong>存储过程和触发器都是万恶之源</strong>)时，我发现DBeaver和PL/SQL在面对同一段SQL脚本时，居然因为一点点语法上的差异而不兼容，这让我内心深处不由得想对Oracle吐槽一番。这是一个什么样的SQL脚本呢？我们一起来看下面的例子：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> <span class="string">"TRI_SYNC_ITEM_VALUE"</span></span><br><span class="line">  <span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">"or_line"</span></span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  v_item_value <span class="built_in">NUMBER</span>(<span class="number">18</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> ITEM_VALUE <span class="keyword">INTO</span> v_item_value <span class="keyword">FROM</span> <span class="string">"order_info"</span> <span class="keyword">WHERE</span> ORDER_GID = :OLD.ORDER_GID;</span><br><span class="line">  v_item_value := v_item_value - :OLD.PACKAGE_COUNT * NVL(to_number(:OLD.OL_UDF7),0);</span><br><span class="line">  IF v_item_value < 0 THEN</span><br><span class="line">      v_item_value:= 0;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="string">"order_info"</span> <span class="keyword">SET</span> ITEM_VALUE = v_item_value <span class="keyword">WHERE</span> ORDER_GID = :OLD.ORDER_GID;</span><br><span class="line"><span class="keyword">END</span> <span class="string">"TRI_SYNC_ITEM_VALUE"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"sys_upgrade_history"</span>(UPGRADE_TYPE,VERSION_NO,UPDATE_DATE,REMARK) <span class="keyword">VALUES</span>(<span class="string">'版本更新'</span>,<span class="string">'10005'</span>,<span class="keyword">SYSDATE</span>,<span class="string">'Normal'</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><p>这是实际业务中编写的一个简单触发器脚本，我们通常的编写习惯是，在写完触发器或者存储过程以及函数后，会在升级历史中插入一天新纪录，所以，这个脚本实际上由两部分组成。如果这段脚本分两次执行，那么在DBeaver和PL/SQL中效果是一样的。可如果我们希望一次执行整个脚本，根据PL/SQL的规范，一个PL/SQL脚本由如下结构组成：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    [声明部分]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    [过程部分]</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></tbody></table></figure><p></p><p>这个时候，我们就要在这两部分脚本间增加一个分隔符——<strong>/</strong>。可尴尬的是，这种写法在DBeaver中是无法编译执行的，因为它认为<strong>/</strong>是个无效的SQL关键字。我一直疑心这是个Bug，因为Github上曾有人提过类似的Issue，作者回复说，DBeaver并没有完全实现PL/SQL语法的解析，而最近更新的6.0版本中提到：对Oracle环境的存储过程编译进行了强化。博主尝试升级到最新版本，发现这个问题依然存在，哪怕用Ctrl+Enter来执行一样会报错，于是我想从这件事吐槽下某数据库，从哪里说起呢，就从PL/SQL说起吧！</p><h1 id="标准与私货"><a href="#标准与私货" class="headerlink" title="标准与私货"></a>标准与私货</h1><p>我想一开始学习SQL语法的时候，大家绝对不会想到，看起来和谐而统一的结构化查询语言，其实是貌合神离。为什么这样说呢？因为我真的不知道，一个时间函数居然可以有SYSDATE、NOW()和GETDATE()三种写法，我更不知道，有一天会因为不知道ROWNUM而被面试官鄙视，更不必说每种数据库都会定义一两种不一样的数据类型，这东西号称是有一个标准吗？比如SQL92/99这个标准定义了DML(数据操作语言)、DDL(数据定义语言)、DCL(数据控制语言)和TCL(事务控制语言)四种分类，所以，SQL的定位其实更接近于交互式命令行，它是命令式的查询语言，而非过程式的声明语言。</p><p>可在标准化进程缓慢的大背景下，每一家数据库厂商都在往自家产品里夹藏私货，以甲骨文为首的Oracle发展出了PL/SQL、以微软为首的SQLServer发展出了T-SQL。其实，我很能理解这种标准跟不上时代发展需要的阵痛，就像我们的Web领域直到10年前后才提出了HTML5标准，在此之前，我们为不同的浏览器的兼容性煞费苦心，兼容IE8与否甚至成为了评价技术好坏的一个隐性标准，可说句实话，浏览器的Bug难道不应该让浏览器厂商来修复吗？关前端工程师什么事？同样的，数据库间的差异，让我们的脚本失去了可移植性，触发器、存储过程这种严重依赖数据库的东西，一旦更换了数据库，基本等于要重头再写一遍，如今的小程序让Web变成信息孤岛，甚至Chrome正在变成下一个IE，这就是所谓“屠龙少年战胜恶龙，自身亦化为恶龙吗”？</p><p>这种不统一带来的弊端就是，我们永远写出可以完美“跨”数据库的SQL，现在跨平台基本成为了大家的共识，因为操作系统间的差异越来越小，以我个人为例，我使用的大多数软件都可以找到对应的Linux版本，这样做的好处是，我可以在无差别地从Windows切换到Linux。可现在，我们必须在MySQL里使用VARCHAR、而在Oracle里使用NVARCHAR，而在SQLServer里又要使用NVARCHAR2，可明明它们都是表示一样的东西啊，类似的还有MediumText和CLOB，是不是起一个不一样的名字会显得与众不同呢？更不必说在DDL中表约束相关的语法存在差别了。我被告知Oracle脚本中表名要用双引号括起来，理由是Oracle区分大小写，加上双引号就可以让它忽略大小写，忽略大小写不应该给Oracle一个设置吗？为什么要让我再写个多余的双引号呢？诸如此类，举不胜举。</p><h1 id="SQL是个好DSL吗？"><a href="#SQL是个好DSL吗？" class="headerlink" title="SQL是个好DSL吗？"></a>SQL是个好DSL吗？</h1><p>SQL标准定义的SQL，就是一个以集合论为基础的结构化查询语言，它天生适合的场景就是，你在命令行中输入SQL语句，然后它去执行你输入的SQL语句，它就像我们大多数情况下使用的交互式命令行，不然，为什么MySQL要提供命令行版本，主流的数据库管理工具都提供了输入SQL语句的窗口。可我们同样能意识到，SQL的表达能力有限，它无法表达顺序、条件、循环这种基本的程序结构，所以，数据库厂商几乎都对SQL标准进行了扩展，像PL/SQL和T-SQL中都提供了这些语法，进而催生出函数、触发器、存储过程一系列“万恶之源”，可从编程语言的角度来看，SQL算是个好DSL吗？</p><p>SQL试图从编程语言中获得“灵感”的思路是正确的，但总给人一种买椟还珠的感觉，譬如使用大量的英文关键字来作为保留关键字，可你很难想象，像GROUP BY和ORDER BY这样的关键字，居然可以保留中间一个甚至多个空格，既然是关键字，为什么不选择一个单词，而选择一个组合词呢？这个世界上用Begin和End的编程语言，我使用过的有Pascal和Basic，但现在我几乎不会再用它们，为什么呢？因为使用花括号(<strong>{}</strong>)更符合这个世界的发展趋势，你看Python居然用缩进代替花括号，是打算时刻用游标卡尺写代码吗？</p><p>全世界都默认用分号作为一个语句的结束，那么，当多个语句放在一起的时候，直接相互间用分号隔开，编译器或者解释器都能识别，就算不喜欢写分号的JavaScript，最新的标准提案里不还是建议要写吗？可为什么到了PL/SQL这里，明明已经用分号作为结束符了，偏偏还要再用一个/作为分隔符。我们都知道/<em>会被当做是注释的开始，那么如果我在PL/SQL里恰好在End;后写上一句/</em>，你告诉我，这到底代表什么意思？明明像&&、||、^等这样的运算符，都是有固定含义，并且大家所有编程需要都默认了这个原则，可偏偏有人用||来连接字符串，你告诉我，用+不好吗？就像从小到大，÷都会被认为表示一个除法运算，结果突然有一天，有人用这个符号来表示加法运算，你说你是不是有种被当做傻子的感觉。全世界都用=表示赋值运算，结果PL/SQL自作聪明地搞了个:=，我想说，你真的考虑过使用者的体验吗？</p><p>你甚至连分页、排序、分组这种事情，都无法在不同的数据库上获得一致的书写体验，读取指定数目的数据库记录，居然要纠结用到底用Limit还是Top，像Select Into这样把指定列存储到指定变量中的操作，居然要求使用者来限制结果集的数目，从函数的角度来看，返回的必然是结果集中的一个元素，只有这样才可以赋值给指定的变量，可问题是存在多条记录的时候，你必须用游标去循环读取，而不能像大多数编程语言一样，直接Map()到一个类型上然后ToList()，可能是我对SQL的要求太高了吧，毕竟它就是个面向过程的语言，OO不OO的没那么重要，可明明你可以抛出异常啊，可以对字符串做截取啊正则啊，可以在控制台里输出日志啊，可以调用各种有的没的的内部函数啊，elsif可能是因为e不发音，就像usr绝对不是拼写错误……</p><p>Python的缩进虽然为人所不齿，但它至少和大部分编程语言一样，单独一行的程序语句和由多行程序组成的程序块之间，并不需要明显的分割符号。可MySQL需要用DELIMITER $$这种奇怪的符号，PL/SQL需要用/这种奇怪的符号，SQLServer需要用@这种奇怪的符号，还有大名鼎鼎的虚拟表DUAL。也许这些东西写多了就可以记住，就像我现在可以分清SYSDATE、NOW()和GETDATE()，可它带来的问题是什么呢，大多数的触发器、存储过程、函数都是没有移植性可言的，很多年前，我们讲设计模式，最喜欢觉的例子就是，如果项目发生变动，需要更换数据库，我们要怎么设计能不改动代码，现在看起来，当时还是太天真了，真要换了数据库，估计就是重新做了，敢把全部业务写到数据库里，Web就做一个展示层的项目，有生之年应该是不会换数据库啦！</p><h1 id="多元与统一"><a href="#多元与统一" class="headerlink" title="多元与统一"></a>多元与统一</h1><p>这个世界的离奇之处在于，人们一边渴望在标准的庇护下幸福生活，又一边渴望可以超脱标准去发展独立的个性，如你我所见，多元与统一，构成了这个世界永恒的旋律，或许是因为那句名言——没有永远的敌人，只有永远的利益。可对比Web的标准化与SQL的标准化，我们却看到了截然不同的场景，虽然Chrome浏览器市场份额的不断提高，加上微软、Mozilla等“浏览器巨头”一起推动，HTML5和CSS4，让大量的工作得到了简化，尤其像WebSocket、Drag&drop、Canvas等API的推出，这带来的好处是什么呢？大家不再去重点关注浏览器的兼容性问题，各种天花乱坠的炫酷特效不再通过JavaScript去控制。一个标准的API + 一个支持降级的profily，基本就可以覆盖到主流的浏览器，就算有小程序这种偏离标准的解决方案，回顾近几年整个前端领域的趋势，可以说，一切都在向着好的方向发展。</p><p>可数据库领域发生了什么，依稀记得甲骨文和Google因为Android使用了Java而官司连连，Google不得不推出一种新的基于JVM的语言——Kotlin；依稀记得甲骨文在开源社区的强烈反对下收购了MySQL，社区不得不继续维护MySQL的开源分支——MariaDB。从这两件事情，我完全提不起对甲骨文这家公司的好感，虽然大家都说Oracle品质卓越，可实际使用下来，经常出问题的Oracle。从LAMP时代开始，MySQL就以其免费、轻量的特点广泛应用在互联网产品中，直至今天有大量的云产品使用着MySQL，而Oracle和SQLServer则被更多地使用在私有部署的场景中。虽然，我承认把数据掌握在自己手里会放心些，可当你没有能力去维护这些东西时，付出的时间和精力远远要比这多。甲骨文收购了那么多公司的产品，时至今日，对整个行业的标准化有什么推动呢？Oracle数据库依然难装、难用，PL/SQL同样难用得要命，可我们这世界一直都很奇怪，最流行的偏偏未必是最好的，据说Oracle的代码写得非常差，开发人员表示不会在为它继续开发新功能。</p><p>可能有时候，我们完全说不出来，一件东西是好还是坏，就像JavaScript能在前端开发流行，是因为没有其它的选择，你说这门语言没有缺点吗？当然有，JavaScript里各种“骚操作”和“黑科技”，甚至吐槽三天三夜都说不完。同样，还有Python这门语言，大家都觉得它的解释器慢腾腾的，动态语言遇上大型项目简直就是火葬场，还有神来之笔—— 通过缩进来代替花括号。我最终还是在PL/SQL里执行了我的脚本，只要我在使用DBeaver 的时候，人肉地区分/前后的SQL语句就可以了。果然，我骨子里还是一个不喜欢写SQL脚本的人，因为我认为这么别扭的东西简直不能称之为脚本，你看看Lua，再看看Python，有哪一门脚本语言有SQL脚本这样别扭呢？数据库对我而言，就是一个存取数据的“潘多拉魔盒”，索引啊，触发器啊，数据库任务啊，执行计划啊，存储过程啊，难道不属于暴露了太多细节给用户吗？我天天用这个数据库，我每天用哪些表，我每天用哪些字段，你作为一个成熟的数据库了，居然不能自己去解决这些问题，我对你很失望啊，请记住，程序员比任何人都喜欢偷懒。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="DBeaver" scheme="https://qinyuanpei.github.io/tags/DBeaver/"/>
    
      <category term="PL/SQL" scheme="https://qinyuanpei.github.io/tags/PL-SQL/"/>
    
      <category term="Oracle" scheme="https://qinyuanpei.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>zTree删除/拖拽子节点保留父节点分组样式</title>
    <link href="https://qinyuanpei.github.io/posts/1397717193/"/>
    <id>https://qinyuanpei.github.io/posts/1397717193/</id>
    <published>2019-04-12T12:37:10.000Z</published>
    <updated>2019-05-10T10:39:36.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近需要在项目中实现报表的自定义设置功能，即用户可以针对报表新建自定义分组，分组间可以互相嵌套，分组及分组内的报表需要支持拖拽排序、编辑、删除……相信听到这里，你大概明白我要实现一个什么样的功能了。不错，我要实现一个集美观、功能于一身的树形菜单。本着“不要重复制造轮子”的原则，我在考察了JQuery EasyUI、layui、Bootstrap、Kendo UI等不同框架提供的“树形菜单”组件以后，最终选择了<a href="http://www.treejs.cn/v3/main.php#_zTreeInfo" target="_blank" rel="noopener">zTree</a>这样一个插件，虽然这个官网看上去相当复古，虽然最终的成品依然被同事吐槽丑，可它的确完美得实现了我想要的功能，是当之无愧的“树形菜单”王者。</p><p>zTree的API相当复杂，尤其是属性和事件的种类，简直叫一个繁杂，这是大部分基于jQuery插件的一个特点。不过zTree的使用还是比较简单的，我们只需要提供一个DOM节点，一份JSON数据，zTree就可以帮我们在界面上渲染出一个完整的树形菜单：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = res.Data;</span><br><span class="line"><span class="keyword">var</span> zNodes = <span class="built_in">JSON</span>.parse(data.TreeData);</span><br><span class="line">$.fn.zTree.init($(<span class="string">"#reportTree"</span>), setting, zNodes);</span><br></pre></td></tr></tbody></table></figure><p></p><p>zTree的节点是由JSON结构来定义的，其基本结构是{name:”节点名称”,children:[]}，父子节点采用相同的结构相互嵌套。例如，下面是博主所使用的数据结构：<br></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"id"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"全部报表"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"pId"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"viewUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"children"</span>: [</span><br><span class="line">      {</span><br><span class="line">        <span class="attr">"id"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"示例报表A"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"pId"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"viewUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"children"</span>: [</span><br><span class="line">          {</span><br><span class="line">            <span class="attr">"id"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"示例报表B"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"pId"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"viewUrl"</span>: <span class="string">"/MyReport/List?menuid=38c0e1ce7442419f9e3305a03b819128"</span>,</span><br><span class="line">            <span class="attr">"children"</span>: <span class="literal">null</span></span><br><span class="line">          },</span><br><span class="line">          {</span><br><span class="line">            <span class="attr">"id"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"示例报表C"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"pId"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"viewUrl"</span>: <span class="string">"/MyReport/List?menuid=e88ae4a5c07445a59c2f04ec405e6158"</span>,</span><br><span class="line">            <span class="attr">"children"</span>: <span class="literal">null</span></span><br><span class="line">          }</span><br><span class="line">        ]</span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><p>参考官网上的DEMO，我们基本上就可以快速上手zTree，博主这里就是结合了节点的编辑、拖拽这两个功能。不过，按照官网上的DEMO会存在两个Bug，与我们实际的期望有所不同，<strong>其一，是当一个分组下的子节点被全部删除后，这个分组的图标会变成一个子节点的图标；其二，是当个一个分组下的节点被全部拖拽到分组以外的地方，这个分组的图标会变成一个子节点的图标。</strong>这两个Bug是由测试小姐姐们发现的，zTree是我引入到项目中来的，这个Bug哪怕跪着都要改完，说多了都是泪啊，下面给出解决方案：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRemove</span>(<span class="params">e, treeId, treeNode</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> zTree = $.fn.zTree.getZTreeObj(reportTreeId);</span><br><span class="line">    <span class="keyword">var</span> root = zTree.getNodes()[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (treeNode.isParent) {</span><br><span class="line">        reports = GetReportsByNode(treeNode)</span><br><span class="line">        <span class="keyword">var</span> parentNode = treeNode.getParentNode();</span><br><span class="line">        <span class="keyword">if</span> (parentNode != <span class="literal">null</span> && (parentNode.children == <span class="literal">null</span> || parentNode.children.length == <span class="number">0</span>)) {</span><br><span class="line">            parentNode.isParent = <span class="literal">true</span>;</span><br><span class="line">            parentNode.isOpen = <span class="literal">true</span>;</span><br><span class="line">            zTree.updateNode(parentNode);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyNode;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beforeDrop</span>(<span class="params">treeId, treeNodes, targetNode, moveType, isCopy</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> zTree = $.fn.zTree.getZTreeObj(reportTreeId);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < treeNodes.length; i++) {</span><br><span class="line">        <span class="keyword">var</span> treeNode = treeNodes[i];</span><br><span class="line">        <span class="keyword">var</span> parentNode = treeNode.getParentNode();</span><br><span class="line">        <span class="keyword">if</span> (parentNode != <span class="literal">null</span> && (parentNode.children == <span class="literal">null</span> || parentNode.children.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>{ <span class="keyword">return</span> s.name != treeNode.name; }).length == <span class="number">0</span>)) {</span><br><span class="line">            emptyNode = parentNode;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event, treeId, treeNodes, targetNode, moveType, isCopy</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> zTree = $.fn.zTree.getZTreeObj(reportTreeId);</span><br><span class="line">    <span class="keyword">if</span> (emptyNode != <span class="literal">null</span>) {</span><br><span class="line">        emptyNode.isOpen = <span class="literal">true</span>; emptyNode.isParent = <span class="literal">true</span>;</span><br><span class="line">        zTree.updateNode(emptyNode);</span><br><span class="line">        emptyNode = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>OK，实际项目中可能需要存储这个树形结构，因为你能想象，用户编辑完这样一个“个性化”的设置以后，我们还要根据这个设置来加载树形菜单，以达到个性化的目的。那么，怎么获得这个树形结构呢，理论上我们只需要通过zTree.getNodes()方法获得整个树的节点信息，然后将其序列化为JSON即可，可实际上zTree会在树上附加“冗余”信息，所以，博主的做法是，通过递归来遍历整个树的节点，获取其中的关键信息，这里以name字段为例：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetTreeData</span>(<span class="params">zTree</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> data = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < zTree.length; i++) {</span><br><span class="line">        <span class="keyword">var</span> treeNode = zTree[i];</span><br><span class="line">        <span class="keyword">if</span> (!treeNode.isParent) {</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">            obj.name = treeNode.name;</span><br><span class="line">            data.push(obj)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">            obj.name = treeNode.name;</span><br><span class="line">            obj.children = GetTreeData(treeNode.children)</span><br><span class="line">            data.push(obj)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>好了，最近接触到都是些零碎的东西，大家都讲究着看看吧，可以说没有什么干货。折腾前端最大的感悟就是，做一个页面其实并不难，真正难的是集成到一个系统里，像iframe和tab这种“垃圾”的东西，集成到一起就像猜地雷，你永远不知道别人埋了什么坑在里面，以上就是这篇博客啦，晚安！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端开发" scheme="https://qinyuanpei.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://qinyuanpei.github.io/tags/JavaScript/"/>
    
      <category term="zTree" scheme="https://qinyuanpei.github.io/tags/zTree/"/>
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>分享两种实现前端拖拽排序的方案</title>
    <link href="https://qinyuanpei.github.io/posts/2436573863/"/>
    <id>https://qinyuanpei.github.io/posts/2436573863/</id>
    <published>2019-03-31T12:49:37.000Z</published>
    <updated>2019-05-10T10:39:36.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hi，大家好，在经历了两周多的“写Bug”、“改Bug”死循环后，又一个迭代终于在习以为常的加班生活中结束啦！联想到最近在Github上发起的<a href="https://996.icu/#/zh_CN" target="_blank" rel="noopener">“996.icu”</a>事件，不禁令人由衷地感慨生活不易，所谓”起风了，唯有努力生存“。其实，我反对是加班常态化所导致的无效加班，既然努力工作是为了更好的生活，可如果因此而模糊了工作和生活的界限，这到底是一件好事还是一件坏事呢？想想每个周末被工作群里消息支配的失落感，我希望我有可以自由支配的时间，即使我看起来比别人年轻，即使我下班后依旧孤身一人，因为用时间来换钱这件事情，着实是件性价比不高的事情，货币会一天天地贬值直至我们老去，可那些失去的时间就永远地失去了。好了，”业精于勤荒于嬉“，今天我们来说前端中实现拖拽排序这件事情。</p><p>其实，这件事情说起来挺尴尬的，我们曾经为用户提供过某种<strong>”智能“</strong>的体验，我们通过对用户的行为进行分析，为其推荐了个性化的菜单项，甚至根据用户的使用频率对菜单进行了排序。可事实上用户的反响并不是非常强烈，在经过一段时间的使用后，用户依然觉得这个功能相当地”鸡肋“，这件事情告诉我们一个真相，<strong>即无论是产品设计还是需求研讨，最好不要轻易地代入用户的角色</strong>。最终的结果是我们打算为用户提供自定义的功能，考虑到操作的便利性问题，我们放弃了那种通过上下箭头按钮进行排序的方案，这样就回到了本文的主题，如何在前端中对一组列表进行拖拽排序，最终我们选定了两组方案，它们分别是<a href="https://github.com/dbushell/Nestable" target="_blank" rel="noopener">Nestable</a>和<a href="http://sortablejs.github.io/Sortable/" target="_blank" rel="noopener">Sortable</a>。</p><h1 id="Nestable方案"><a href="#Nestable方案" class="headerlink" title="Nestable方案"></a>Nestable方案</h1><p>Nestable是一个基于jQuery的插件，是一个在Github上开源的项目，据作者声称，这是一个”拖放具有鼠标和触摸兼容性的分层列表”的方案。这里针对触摸兼容性的支持可以忽略不计，因为如今都9012年了，博主依然在做传统前端页面的开发，这里博主最感兴趣的一点是，它可以支持分层列表，换言之，我们的列表元素是可以有层级关系、是可以嵌套的，唯一令人有点不爽的就是它依赖jQuery了，在这样一个连Github和Bootstrap都在努力移除jQuery的时代，没有jQuery的历史包袱，意味着我们可以大胆地去做现代前端应该做的事情。好了，我们来看看Nestable具体是怎么使用的吧！首先，我们定义一个简单的HTML结构：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"dd-list"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dd-item"</span> <span class="attr">data-id</span>=<span class="string">"1"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd-handle"</span>></span>Item 1<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dd-item"</span> <span class="attr">data-id</span>=<span class="string">"2"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd-handle"</span>></span>Item 2<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dd-item"</span> <span class="attr">data-id</span>=<span class="string">"3"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd-handle"</span>></span>Item 3<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"dd-list"</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dd-item"</span> <span class="attr">data-id</span>=<span class="string">"4"</span>></span></span><br><span class="line">                    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd-handle"</span>></span>Item 4<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">                <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dd-item"</span> <span class="attr">data-id</span>=<span class="string">"5"</span>></span></span><br><span class="line">                    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dd-handle"</span>></span>Item 5<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">                <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">            <span class="tag"></<span class="name">ol</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">ol</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p>接下来，我们可以使用如下的JavaScript代码来初始化整个列表，果然，一股jQuery风扑面而来：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.dd'</span>).nestable({</span><br><span class="line">  <span class="comment">/* config options */</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>然后，我们就可以看到下面的效果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/01/Arjibq.gif" alt="nestablejs-demo" title>                </div>                <div class="image-caption">nestablejs-demo</div>            </figure><p>怎么样？看起来效果还不错吧！不过博主在前期调研的过程中发现，它对于复杂的层级关系就无能为力啦，可能是博主打开的姿势不对吧！如果希望对列表做更深层次的定制，它需要配置的属性会非常非常的多，而且它有一套内在约束在里面，譬如className、nodeName等等，虽然这些都可以去配置，但要想像作者一样运用得好，依然是需要花费大量时间来学习它的API。</p><p>说到这里，对于Nestable，我唯二喜欢的一个feature是，它可以实时地获取到排序后的节点信息，而且是序列化后的JSON格式哦，因为当我们要保存用户的排序结果时，有这样一个接口简直太棒啦有木有！这里需要说明的是，所有具备类似<strong>data-</strong>属性的节点都可以被序列化，熟悉前端的朋友一定知道，这是一个HTML5中的扩展功能，可以让我们在节点上附带更多的数据信息，在Bootstrap中经常需要用到这一特性。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.dd'</span>).nestable(<span class="string">'serialize'</span>);</span><br></pre></td></tr></tbody></table></figure><p>继续以这个例子为例，我们将会得到下面的JSON信息：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[{<span class="string">"id"</span>:<span class="number">1</span>},{<span class="string">"id"</span>:<span class="number">2</span>},{<span class="string">"id"</span>:<span class="number">3</span>,<span class="string">"children"</span>:[{<span class="string">"id"</span>:<span class="number">4</span>},{<span class="string">"id"</span>:<span class="number">5</span>}]}]</span><br></pre></td></tr></tbody></table></figure><p></p><p>不过，遗憾的是，貌似作者已经不打算维护这个项目啦，最后一次维护时间已经是6年前，毕竟属于jQuery的辉煌时代都已经过去，何况是基于jQuery的一个插件呢？可这种频繁修改DOM结构引发浏览器重绘的操作，在大前端时代会消失吗？或许并不会。关于这个项目更多的使用细节，大家可以到它的<a href="https://github.com/dbushell/Nestable" target="_blank" rel="noopener">Github</a>主页去了解。</p><h1 id="Sortable方案"><a href="#Sortable方案" class="headerlink" title="Sortable方案"></a>Sortable方案</h1><p><a href="https://sortablejs.github.io/Sortable/" target="_blank" rel="noopener">Sortable</a>相比Nestable好的一点就是，它对自己的定位是“一个用于可重新排序的拖放列表的JavaScript库”。它不再局限于jQuery这样一个方案上，事实上它支持Vue、React、Angualr、Knockout等将近7个框架，除了支持常规的列表以外，还支持Grid中元素的拖拽，文档相比Nestable要更为完善一点，所以要在项目中使用的话，我个人更推荐Sortable。我们一起来看看如何使用Sortable吧，这里我们选择Bootstrap作为基础样式。首先，我们写一个简单的“列表组”：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-group"</span> <span class="attr">id</span>=<span class="string">"items"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span> <span class="attr">data-id</span>=<span class="string">"0"</span>></span></span><br><span class="line">    Menu1</span><br><span class="line"><span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span> <span class="attr">data-id</span>=<span class="string">"1"</span>></span></span><br><span class="line">    Menu2</span><br><span class="line">    <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span> <span class="attr">data-id</span>=<span class="string">"2"</span>></span></span><br><span class="line">    Menu3</span><br><span class="line">    <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span> <span class="attr">data-id</span>=<span class="string">"3"</span>></span></span><br><span class="line">    Menu4</span><br><span class="line">    <span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure><p>接下来，我们通过JavaScript来给这个列表“施加”魔法——巴拉能量：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'items'</span>);</span><br><span class="line"><span class="keyword">var</span> sortable = Sortable.create(ele);</span><br></pre></td></tr></tbody></table></figure><p>然后我们就可以发现，这个基于Bootstrap的列表居然可以拖拽啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/01/ArjeGF.gif" alt="sortablejs-demo-1" title>                </div>                <div class="image-caption">sortablejs-demo-1</div>            </figure><p>OK，我们继续给这个例子来点魔法，可以让列表元素在拖动的时候高亮显示：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortable = Sortable.create(ele, {</span><br><span class="line">animation: <span class="number">150</span>,</span><br><span class="line">ghostClass: <span class="string">'blue-backgroun-class'</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>可以注意到，拖拽时动画会变得更流畅，被拖拽的元素会以蓝底白字高亮显示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/01/ArjKM9.gif" alt="sortablejs-demo-2" title>                </div>                <div class="image-caption">sortablejs-demo-2</div>            </figure><p>和Nestable类似，我们可以指定一个回调函数来获得排序后的结果，注意到我们这里指定一个dataIdAttr，它告诉Sortable我们将用哪一个值作为数据的主键，从data-text这个命名就可以看出，它的数据是维护在类似<strong>data-</strong>的属性上的，假设我们这里希望获得排序后的菜单，那么，它的打开方式是这样的：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'items'</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span><br><span class="line"><span class="keyword">var</span> sortable = Sortable.create(ele, {</span><br><span class="line">animation: <span class="number">150</span>,</span><br><span class="line">dataIdAttr: <span class="string">'data-text'</span>,</span><br><span class="line">onUpdate: onUpdate,</span><br><span class="line">ghostClass: <span class="string">'blue-backgroun-class'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onUpdate</span>(<span class="params">evt</span>)</span>{</span><br><span class="line"><span class="keyword">var</span> data = sortable.toArray();</span><br><span class="line">result.innerText = <span class="string">"当前排序结果为："</span> + <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>好了，现在可以看到，随着我们对列表进行拖拽，每次都会获得更新以后的列表数据，显然，我们可以将这个结果存到任何地方，这样就可以按用户定义的方式去加载一个列表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/01/ArjMrR.gif" alt="sortablejs-demo-3" title>                </div>                <div class="image-caption">sortablejs-demo-3</div>            </figure><p>以上就是Soratble的基本用法，关于更多的使用细节，<a href="https://sortablejs.github.io/Sortable" target="_blank" rel="noopener">官方文档</a>了解一下。</p><h1 id="HTML5原生方案"><a href="#HTML5原生方案" class="headerlink" title="HTML5原生方案"></a>HTML5原生方案</h1><p>OK，说完了Nestable和Sortable这两个第三方的解决方案，下面我们来说说基于HTML5的原生方案。HTML5标准问世以来，有很多有意思的东西被吸收到标准之中，拖放(drag & drop)就是其中之一。在此之前，我们需要写大量的JavaScript代码来实现这个功能。现在，HTML5中原生支持拖放API，我们不妨考虑通过它来实现一个可拖拽的列表，这里我们继续沿用基于Bootstrap的例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragElement = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> source = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.list-group-item'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i < source.length; i++){</span><br><span class="line">    source[i].addEventListener(<span class="string">'dragstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>{</span><br><span class="line">        dragElement = <span class="keyword">this</span>;</span><br><span class="line">    },<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    source[i].addEventListener(<span class="string">'dragenter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>{</span><br><span class="line">        <span class="keyword">if</span>(dragElement != <span class="keyword">this</span>){</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(dragElement,<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    source[i].addEventListener(<span class="string">'dragleave'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>{</span><br><span class="line">        <span class="keyword">if</span>(dragElement != <span class="keyword">this</span>){</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="keyword">this</span>.parentNode.lastElementChild || <span class="keyword">this</span> == <span class="keyword">this</span>.parentNode.lastChild){</span><br><span class="line">                <span class="keyword">this</span>.parentNode.appendChild(dragElement);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }, <span class="literal">false</span>)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{e.preventDefault();}</span><br><span class="line"><span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{e.preventDefault();}</span><br></pre></td></tr></tbody></table></figure><p>这里唯一需要注意的地方，就是要给每一个className为list-group-item的元素添加draggable属性，并设置该属性为true，这是使用HTML5拖放API的一个前提，换言之，<strong>只有draggable的元素才可以被拖拽</strong>。那么，HTML5中针对拖放的API有哪些呢？针对拖放事件，我们可以抽象出三种角色，它们分别是：</p><ul><li><p>源对象：即对拖拽的对象。它有dragstart、drag和dragend三个事件。</p></li><li><p>过程对象：即被拖拽的对象，在拖拽过程中经过的中间对象，它有dragenter、dragover和dragleave三个事件。</p></li><li><p>目标对象：即被拖拽的对象，最终所放置的对象，它只有一个drop事件。</p></li></ul><p>而在所有的拖拽事件中，都提供了一个数据传递对象dataTransfer，用于在源对象和目标对象间传递数据。例如，我们可以通过setData()来向dataTransfer存入数据，通过getData()来从dataTransfer读取数据，通过clearData()来清理dataTransfer中的数据。此外，还可以通过setDragImage()、effectAllowed属性 和 dropEffect 属性来设置拖拽过程中的图标、拖放的视觉效果等。这里需要注意的是，<strong>IE浏览器不支持dataTransfer对象</strong>。了解了这下，我们就可以做出一个<strong>”简陋“</strong>的拖拽排序功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/01/ArjQq1.gif" alt="sortablejs-demo-4" title>                </div>                <div class="image-caption">sortablejs-demo-4</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇文章主要分享了三种实现列表拖拽排序的方案，在技术选型阶段，主要选择Nestable和Sortable这两种方案，前者对层级节点提供的序列化支持非常好，但经过一番折腾后，发现要想像作者一样用好这个插件，着实是件困难的事情，而且貌似作者已经不再维护这个项目了，最近的代码提交历史大概是6年前，<strong>毕竟属于jQuery的辉煌时代已经过去，何况是一个基于jQuery的插件呢？所以，个人不建议在正式项目中使用Nestable。</strong>相比之下，Sortable的定位要更高一点，<strong>它不再局限于某个UI框架上，理论上任何前端项目都可以使用，从文档的完整性和易用性上，都要比Nestable要更胜一筹</strong>。原本一开始打算写这两种方案的，后来觉得HTML5中提供了拖拽相关的API接口，这种方式不失为一种解决方案。虽然提到HTML5就让人联想到兼容性，可都2019年了，连浓眉大眼的微软(巨硬)都开始在Edge里使用Chrome内核了，兼容性问题还算是个问题吗？所以，这篇文章实际上介绍了三种解决方案，具体使用哪一种，大家可以根据实际情况来决定，好啦，这篇博客就写到这里，谢谢大家，晚安！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端开发" scheme="https://qinyuanpei.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="HTML5" scheme="https://qinyuanpei.github.io/tags/HTML5/"/>
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="拖拽" scheme="https://qinyuanpei.github.io/tags/%E6%8B%96%E6%8B%BD/"/>
    
  </entry>
  
  <entry>
    <title>《阿里巴巴Java开发手册》读书笔记</title>
    <link href="https://qinyuanpei.github.io/posts/1122710277/"/>
    <id>https://qinyuanpei.github.io/posts/1122710277/</id>
    <published>2019-03-20T12:49:37.000Z</published>
    <updated>2019-05-10T10:39:36.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近利用闲暇时间从图书馆借了两三本书来“充电”，因为如果不及时摄取新的营养，感觉会越来越难有新的想法输出出来，尤其是像ServerLess、组件化、分布式等等这样的场景慢慢开始接触，就势必无法再用从前的眼光去看待。大概去年的时候，阿里巴巴发布了「阿里巴巴开发手册」这本小册子，大概不到100页的样子，这次我就挑选了我觉得还不错的关键点，和大家简单分享一下，所以，这是一篇“典型”的读书笔记，下面的编号代表的是指定章节下的第几条规范，例如，1.1.2表示的是第一章第一节中的第二条规范，欢迎大家一起讨论。</p><h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><blockquote><p>1.1.2 代码中的命名严禁使用拼音与英文混合的方式，不允许直接使用中文的方式，纯拼音命名方式更要避免采用。</p></blockquote><p>说明：英文不好可以去查，禁止使用纯拼音或者拼音缩写的命名方式，除了不能“望文生义”以外，对导致别人在调用接口的时候，向这种“丧心病狂”的编码风格妥协，这里不点名批评某SAP提供的OA接口，除了超级难用以外，每次都要花大量时间去对字段。</p><blockquote><p>1.4.3 相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object，可变参数必须放置在参数列表最后。</p></blockquote><p>说明：例如一个接口同时支持单条更新或者批量更新，此时，完全就可以使用param关键字来声明相同的参数类型，而无须定义InsertOne和InsertMany两个方法。</p><blockquote><p>1.4.4 对外部正在使用或者二方库依赖的接口，不允许修改方法签名，以避免对接口调用方产生影响。若接口过时，必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。</p></blockquote><p>说明：对于过期的接口可以通过Obsolete特性来声明过期，这样在编译时期间可以告知使用者该接口已过期。对于WebAPI接口，除非有版本控制机制，否则一律不允许修改已上线的接口签名、参数和返回值。</p><blockquote><p>1.4.17 在循环体内，字符串的连接方式使用StringBuilder的append方法进行扩展。</p></blockquote><p>说明：这一点，在C#中同样适用，因为字符串类型是Immutable的，对字符串进行拼接会产生大量的临时对象。</p><blockquote><p>1.5.7 不要在foreach循环内进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</p></blockquote><p>说明：因为foreach是基于迭代器(IEnumerator)的，在foreach循环内部修改集合，会导致Current和MoveNext()发生混乱，早期的集合使用SynRoot来解决线程安全(内部原理是使用了Interlocked锁)，现在我们使用CurrentBag等线程安全的集合。</p><blockquote><p>1.6.1 获取单例对象需要保证线程安全，其中的方法同样要保证线程安全。</p></blockquote><p>说明：只要类型中有静态成员存在，就要考虑线程安全，因为静态成员隶属于类型而非类型的实例。</p><blockquote><p>1.6.5 SimpleDataFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUntils工具类。</p></blockquote><p>说明：无论所声明的静态成员是否线程安全，都应该考虑到在竞态条件下，可能会出现多个线程同时修改静态成员的风险，此时最好对其进行加锁。</p><blockquote><p>1.6.8 在并发修改同一条记录时，为避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存层加锁，要么在数据库层使用乐观锁，使用version作为更新依据。</p></blockquote><p>说明：所谓“悲观锁”，是指认为数据一定会被篡改，此时，在一个作用域结束前对其进行加锁，典型的如lock关键字。而所谓“乐观锁”，是认为数据不一定会被篡改，此时，通过一个version来作为更新的依据。</p><blockquote><p>1.6.12 在并发场景下，通过双重检查锁(double-checkedlocking)实现延迟初始化的优化问题隐患，推荐解决方案中较为简单的一种(JDK5及以上版本)，即目标属性声明为volatile型。</p></blockquote><blockquote><p>1.7.4 在表达异常的分支时，尽量少用if-else方式。如果不得不使用if…elseif…else方式，请勿超过3层。</p></blockquote><p>说明：当条件不满足时可以直接return，或者先判断不满足的条件，则剩余逻辑默认就是满足条件的分支，尽量避免使用if…elseif…else方式，同时保证分支里的代码足够简单，复杂的逻辑应考虑封装或者用switch…case甚至多态来重构。</p><blockquote><p>1.7.8 循环体的语句要考量性能，以下操作请尽量移至循环体外处理，如定义对象或变量、获取数据库连接，避免进行不必要的try…catch操作。</p></blockquote><p>说明：抛出一个异常是非常简单的，然而捕获一个异常需要付出一定的性能代价，因为它需要捕捉程序异常时的上下文信息，建议在进入循环内部合理检验，覆盖到每一种考虑到的情况，考虑不到的请让它向上抛出。</p><blockquote><p>2.1.2 对大段代码进行try-catch，使得程序无法根据不同的异常做出正确的应激反应，不利于定位问题，这是一种不负责任的表现。</p></blockquote><p>说明：对大段代码进行try-catch，或许可以保证应用程序不崩溃，但在程序异常的一瞬间，可能业务数据已经出错，此时再让程序继续运行下去，不仅无法快速定位出错原因，而且会对下一流程的业务产生“污染”。</p><h1 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h1><blockquote><p>2.1.2 捕捉异常是为了处理它，不要捕捉了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者，然后由调用者在最外层业务中处理异常，并将其转化为用户可以理解的内容。</p></blockquote><p>说明：捕捉了异常一定要去处理它，如果单单是为了记录个错误日志，完全可以通过AOP来记录，底层抛出的异常不允许被“吞掉”，必须将其抛给它的调用者，异常最终需要转化为友好的界面提示。</p><blockquote><p>2.2.5 finally块必须对资源对象、流对象进行关闭操作，如果有异常同样要做try-catch操作(JDK7及以上版本可以使用try-with-resource方式)</p></blockquote><p>说明：因为finally块一定会在return前执行，所以，无论程序是否发生了异常，我们都可以在finally块中对资源对象、流对象、数据库连接等进行关闭或者释放，using其实是try…finally的语法糖，它会自动地在finally块里调用Dispose方法(因为它要实现IDispose接口)。</p><blockquote><p>2.2.7 不能在finally块中使用return。</p></blockquote><p>说明：这里涉及到一个return和finally，尽管return可以提前“跳出”，但对finally来说，不管是否发生异常，它都会执行，在此之前return会把返回值写入内存，等finally块执行结束后，return再“跳出”。C#中finally块中不允许写return，否则会导致编译错误。通常，finally块用来做清理相关的工作。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><blockquote><p>5.1.1 表达是否的概念时，必须使用is_xxx的命名方式，数据类型是unsigned tinyint。其中，1表示是，0表示否。</p></blockquote><p>说明：表达是否最好用0和1来表示，我们用Y和N时经常会出现，开发人员忘记给模型赋值，导致进入到数据库里的数据出现错误数据，而领域模型里又不建议给字段默认值，可如果使用unsigned tinyint类型，它本身就自带默认值0，这样就可以避免这种问题的出现。</p><blockquote><p>5.1.2 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下画线中间只出现数字。</p></blockquote><p>说明：建议全部使用小写，因为主流SQL教程的里关键字都采用大写，但在PLSQL/SQLyog里编写SQL语句时，字段会自动地变成小写，而且不区分大小写，为了避免人格分裂，建议所有字段都用小写。我们表名用小写，表字段用大写，输出的SQL语句看起来特别奇怪。</p><blockquote><p>5.1.13 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><ul><li>不是频繁修改的字段</li><li>不是varchar超长字段，更不能是text字段。</li></ul></blockquote><p>说明：冗余字段是个好东西，但主表和扩展表间的一致性保证需要经过良好的设计，那种把相关表都放在一个事务里处理的做法，都声称是为了保证数据的一致性，可实际过程中依然会存在数据不一致的情况。</p><blockquote><p>5.1.15 当单表行数超过500万行活着单表容量超过2G时，才推荐进行分库分表。</p></blockquote><p>说明：多租户架构下，不同租户采用不同的库，是最简单的数据隔离方案，但缺点是增加了维护多个库的成本。如果要分库分表，最好从框架层面来“切库”，而不要让开发人员自行维护数据库的连接字符串。</p><blockquote><p>5.2.1 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。根据墨菲定律，只要没有唯一索引，必然会有脏数据产生，即使在应用层做了非常完善的检验控制。</p></blockquote><blockquote><p>5.2.2 超过三个表禁止join，需要join的字段，类型必须绝对一致；当多表关联查询时，保证被关联的字段需要有索引。</p></blockquote><p>说明：关系型数据库最值得炫耀的地方就是表多，超过三张表禁止join，实际中根本不现实，所以，建议以业务场景为准，我就曾经join了5张表，大概客户就喜欢看这些东西吧！</p><blockquote><p>5.3.7 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><p>说明：存储过程和触发器是万恶之源，不同数据库下的SQL语句千姿百态，同样的业务逻辑，Oracle、MySQL和SQLServer基本上是三种语法，更不用说$$、/和@这种奇葩的东西了，查询语言就老老实实写查询，写业务了逻辑，SQL真的不行，太垃圾，虽然做权限划分非常容易……</p><blockquote><p>5.3.9 in操作能避免则避免，如实在避免不了，需要仔细评估in后面的集合元素数量，最好控制在1000之内。</p></blockquote><p>说明：这一点表示认同，我们经常遇到这样的情况，先筛选出A表符合条件的所有记录，然后根据A表中某一列(通常是外键)，通过IN操作来筛选出B表中符合条件的所有记录，这个时候，应该注意控制IN后面集合内元素的数目，总之不要太大……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="https://qinyuanpei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="阿里" scheme="https://qinyuanpei.github.io/tags/%E9%98%BF%E9%87%8C/"/>
    
      <category term="Java" scheme="https://qinyuanpei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>聊聊前端跨域的爱恨情仇</title>
    <link href="https://qinyuanpei.github.io/posts/3846545990/"/>
    <id>https://qinyuanpei.github.io/posts/3846545990/</id>
    <published>2019-02-26T15:03:35.000Z</published>
    <updated>2019-05-10T10:39:36.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是过完春节以后的第二周啦，而我好像终于回到正常工作的状态了呢，因为突然间就对工作产生了厌倦的情绪，Bug就像无底洞一样吞噬着我的脑细胞。人类就像一颗螺丝钉一样被固定在整部社会机器上，除了要让自己看起来像个正常人一样，还要拼命地让所有人都像个正常人一样。过年刚经历过被催婚的我，面对全人类近乎标准的“幸福”定义，大概就是我此刻这种状态。其实，除了想自己定义“幸福”以外，我还想自己定义“问题”，因为，这样就不会再有“Bug”了。言归正传，今天我想说的是<strong>前端跨域</strong>这个话题，相信读完这篇文章，你就会明白，这个世界上太多太多的问题，都和你毫无瓜葛。</p><h1 id="故事缘起"><a href="#故事缘起" class="headerlink" title="故事缘起"></a>故事缘起</h1><p>年前被安排去做一个GPS相关的需求，需要通过百度地图API来计算预计到达时间，这并不是一个有难点的需求，对吧？就在博主为此而幸灾乐祸的时候，一个非常醒目的错误出现在Chrome的控制台中，相信大家都见过无数次啦，大概是说我们的请求受到浏览器的同源策略的限制。那么，第一个问题，什么是同源策略呢？我们知道，一个URL通常有以下几部分组成，即协议、域名、端口和请求资源。由此我们就可以引申出同源的概念，当协议、域名和端口都相同时，就认为它们是在同一个域下，即它们同源。相反地，当协议、域名和端口中任意一个都不相同时，就认为它们在不同域下，此时就发生了跨域。按照排列组合，我们可以有以下常见的跨域场景：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许跨域</th></tr></thead><tbody><tr><td><a href="http://www.abc.com/a.js" target="_blank" rel="noopener">www.abc.com/a.js</a> vs <a href="http://www.abc.com/b.js" target="_blank" rel="noopener">www.abc.com/b.js</a></td><td>相同域名下的不同资源</td><td>允许</td></tr><tr><td><a href="http://www.abc.com/1/a.js" target="_blank" rel="noopener">www.abc.com/1/a.js</a> vs <a href="http://www.abc.com/2/b.js" target="_blank" rel="noopener">www.abc.com/2/b.js</a></td><td>相同域名下的不同路径</td><td>允许</td></tr><tr><td><a href="http://www.abc.com:8080/a.js" target="_blank" rel="noopener">www.abc.com:8080/a.js</a> vs <a href="http://www.abc.com:8081/b.js" target="_blank" rel="noopener">www.abc.com:8081/b.js</a></td><td>相同域名下的不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> vs <a href="https://www.abc.com" target="_blank" rel="noopener">https://www.abc.com</a></td><td>相同域名采用不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> vs <a href="http://wtf.abc.com" target="_blank" rel="noopener">http://wtf.abc.com</a></td><td>相同域名下的不同子域</td><td>不允许</td></tr><tr><td><a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> vs <a href="http://www.xyz.com" target="_blank" rel="noopener">http://www.xyz.com</a></td><td>两个完全不同的域名</td><td>不允许</td></tr><tr><td><a href="http://192.168.100.101" target="_blank" rel="noopener">http://192.168.100.101</a> va <a href="http://www.wtf.com" target="_blank" rel="noopener">http://www.wtf.com</a></td><td>域名及其对应的IP地址</td><td>不允许</td></tr></tbody></table><p>那么，我们就不仅要问啦，现在微服务啊、RESTful啊这些概念非常流行，在我们实际的工作中，调用第三方的WebAPI甚至WebService，这难道不是非常合理的场景吗？前端的Ajax，即XMLHttpRequest，和我们平时用到的RestSharp、HttpClient、OkHttp等类似，都可以发起一个Http请求，怎么在客户端里用的好好的东西，到了前端这里就突然出来一个<strong>“跨域”</strong>的概念呢？这是因为从原理上来说，这些客户端都是受信的“用户”(<strong>好吧，假装是被信任的</strong>)，而浏览器的环境则是一个<strong>“开放”</strong>的环境。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhbqwfadj20to02sdfw.jpg" alt="URI_Syntax_Diagram" title>                </div>                <div class="image-caption">URI_Syntax_Diagram</div>            </figure><p>举一个例子，你在家的时候，可以随意地把手插进自己的口袋，因为这是你的私有环境。可是当你在公共环境中时，你是不允许把手插进别人口袋的。所以，浏览器有“跨域”限制，本质上是为了保护用户的数据安全，避免危险地跨域行为。试想，没有跨域的话，我们带上Cookie就可以为所欲为了，不是吗？实际上，同源限制和JavaScript没有一丁点关系，因为它是W3C中的内容，是浏览器厂商要这样做的，我们的请求其实是被发出去了，而它的响应则被浏览器给拦截了，所以我们在控制台中看到“同源策略限制”的错误。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhciom21j211q04lx2k.jpg" alt="喜闻乐见的跨域拦截" title>                </div>                <div class="image-caption">喜闻乐见的跨域拦截</div>            </figure><h1 id="十八般武艺"><a href="#十八般武艺" class="headerlink" title="十八般武艺"></a>十八般武艺</h1><p>好了，既然现在浏览器有这个限制，那为了客户着想，我们还是要去解决这个问题(对吧？)，虽然我至今想不明白，适配浏览器为什么会成为我们的工作之一[doge]。打开Google搜索“前端跨域”，于是发现了解决跨域问题的各种方案，这里选取最具代表性的JSONP和CORS。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>首先，我们来说说JSONP，什么是JSONP呢？我们知道，通常RESTful接口返回的都是JSON，而JSONP返回的是一段可以执行的JavaScript代码，我们所需要的数据就被“包裹”在这段代码中，这就是JSONP，即<strong>JSON Padding</strong>的得名由来。在实际应用中，服务的提供方会根据调用方传入的回调函数(callback)来组织返回数据，譬如<strong>callback({“name”:”tom”,“gender”:”male”})</strong>。这就说到一个点，<strong>并不是所有的API接口在调用的时候出现跨域问题，都可以通过JSONP的方式来解决，因为它需要后端来配合组织返回数据</strong>。这里我们以“不蒜子”这个静态博客中使用最多的访问量统计工具为例，通过查看页面源代码，我们了解到它是通过JSONP来返回数据的。为什么它要用这种方式来返回数据呢？其实，我们仔细想想就能明白其中的缘由，因为像Hexo、Jekyll这种静态博客大多都是没有后端服务支持的，所以，它要访问“不蒜子”的统计服务，就必然会存在跨域的问题啊！那怎么解决这个问题呢？当然是选择JSONP啦！这里我们以Postman调用不蒜子接口为例，可以发现它的返回值是下面这个样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhe1rnprj218u08sx6p.jpg" alt="在Postman中调用" 不蒜子"接口" title>                </div>                <div class="image-caption">在Postman中调用"不蒜子"接口</div>            </figure><p>博主计划在接下来的时间里，迁移不蒜子的统计数据到LeanCloud上，届时博主会使用最喜欢的Python，来抓取这些访问量数据，因为JSONP返回的都不是JSON数据，因此再处理这些数据的时候，需要用正则来匹配这些结果。为什么在前端领域没有这些问题呢，因为JSONP返回的是世界上最<strong>“任性”</strong>的语言——<strong>JavaScript</strong>，当然，这些会是下一篇甚至下下一篇里的内容啦。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>好了，下面我们说说CORS这种方案。CORS，即跨域资源共享，是一种利用HTTP头部信息访问不同域下的资源的机制。我们在前面提到过，发生跨域访问时，其实请求已经发出去了，但响应则被浏览器给拦截住了。那么，CORS说白了就是它可以通过HTTP头部信息，告诉浏览器来自哪些域的请求可以被允许，来自哪些域的请求应该被禁止。如果说JSONP多少带着点“hack”的意味儿，那么CORS就可以说是被官方认可的跨域解决方案啦！这种方案需要启用新的HTTP头部字段，具体可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">这里</a>。</p><p>按照定义，浏览器会将CORS请求分为<strong>简单请求</strong>和<strong>非简单请求</strong>两类。对于简单请求，浏览器会对请求的头部进行“魔改”，即增加一个Origin字段，这样只要后端接口支持CORS跨域，就可以接收这些跨域请求，并做出回应，即在响应的头部信息中返回Access-Control-Allow-Origin等字段。而对于非简单请求，通常会先发出一个OPTIONS的“预检请求”，只有这个验证过程通过以后，主请求才会被发起。那么浏览器是怎么验证请求是否通过的呢？答案就是：检查<strong>Origin</strong>字段是否包含在<strong>Access-Control-Allow-Origin</strong>中。当验证不通过时，浏览器就会输出同源策略限制的错误。这就是CORS，浏览器和服务端分别通过响应、请求的HTTP头部信息来<strong>“商量”</strong>要不要跨域。</p><h1 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h1><p>说了这么多关于“跨域”的话题，其实博主想说的是，没有银弹。这是一位前辈高人，曾经对博主反复说过的话。现在我们来看JSONP，会发现它本质上是利用了浏览器的<strong>“漏洞”</strong>。为什么这样说呢？因为在浏览器中，<strong>所有具备src属性的HTML都是可以跨域的，譬如script、img、iframe、link这四个标签，我们赖以生存的CDN加速、图床、插件等等都是基于这一“漏洞”的产物</strong>。所以，很多人问为什么$.ajax可以跨域，但原生的XMLHttpRequest则不可以呢？因为jQuery实际上把JSONP做成了一种语法糖，这就就会给人一种ajax可以跨域的错觉。</p><h2 id="JSONP？其实就是JS"><a href="#JSONP？其实就是JS" class="headerlink" title="JSONP？其实就是JS"></a>JSONP？其实就是JS</h2><p>JSONP实际上返回的是可以执行的JavaScript，即text/javascript，它和我们所使用的大多数JavaScript并无区别，所以，你可以想到，当我们把一个远程地址赋值给script标签的src属性时，它和我们引用CDN上的医院文件并无区别，这正是JSONP的秘密所在，显然它只支持Get方式，当我们想要支持更多方式的时候，我们需要的是CORS，一起来看下面这段代码，我们首先来写一个简单的API接口：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET api/user/5?callback=</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"{id}"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> id, <span class="keyword">string</span> callback</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">var</span> userInfo = UserInfoService.Find(x => x.UserId == id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) <span class="keyword">return</span> NotFound();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(callback))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//返回JSON</span></span><br><span class="line">        Response.ContentType = <span class="string">"application/json"</span>;</span><br><span class="line">        <span class="keyword">return</span> Json(userInfo);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//返回JSPNP</span></span><br><span class="line">        Response.ContentType = <span class="string">"application/javascript"</span>;</span><br><span class="line">        <span class="keyword">return</span> Content(<span class="string">$"<span class="subst">{callback}</span>(<span class="subst">{JsonConvert.SerializeObject(userInfo)}</span>)"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OK，写完这个接口以后，我们首先来尝试在前端页面中调用这个接口，为了尽可能地减少依赖，我们这里用最新Fetch API来代替$.ajax()，毕竟现在都是2019年了呢，Github和Bootstrap相继宣布从代码中移除jQuery。大家都知道，原生的xhr和Date对象一样，简直难用得要命，而这一切在新的Fetch API下，会变得非常简单：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于Fecth API调用JSONP</span></span><br><span class="line">showUserByFetch:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">      fetch(<span class="string">"https://localhost:5001/api/user/1"</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>{</span><br><span class="line">          <span class="keyword">return</span> response.json();</span><br><span class="line">        })</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>{</span><br><span class="line">          showUser(user);</span><br><span class="line">        });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>果然，就算使用最新的Fetch API，浏览器还是会因为同源限制策略而拦截我们的请求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhhcqa78j211s04nq3k.jpg" alt="浏览器中再次出现同源限制错误" title>                </div>                <div class="image-caption">浏览器中再次出现同源限制错误</div>            </figure><p>那么，试试用JSONP的思路来解决这个问题。注意到，为了兼容JSONP方式调用，我们在API接口中增加了一个callback参数，这个参数实际上就是预先在客户端中定义好的方法的名字啦！既然JSONP返回的是可执行的JavaScript，那么我们在页面里增加一个Script标签好了：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><script src=<span class="string">"https://localhost:5001/api/user/1?callback=showUser"</span>><span class="xml"><span class="tag"></<span class="name">script</span>></span></span></span><br></pre></td></tr></tbody></table></figure><p>其中，showUser是一个预先定义好的JS函数，其作用是输出用户信息到页面上：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showUser</span>(<span class="params">user</span>)</span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'jsonp-result'</span>);</span><br><span class="line">  result.innerText = <span class="string">'用户ID：'</span> + user.uid + <span class="string">", 姓名："</span> + user.name + <span class="string">', 性别：'</span> + user.gender;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的showUser()方法确实被执行了，所以，到这里我们可以对JSONP做一个简单总结：<strong>JSONP是一种利用script标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的JavaScript，客户端需要事先定义好接收数据的方法，两者通过callback参数建立起联系，返回类似callback({“name”:”tom”,“gender”:”male”})结构的数据，因此JSONP请求必然且只能是一个GET请求</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhf0sls2j21h8090gn0.jpg" alt="通过Script标签调用JSONP" title>                </div>                <div class="image-caption">通过Script标签调用JSONP</div>            </figure><p>既然通过Script标签可以调用一个JSONP接口，那么我们不妨试试动态创建Script标签，然后你就会发现这两种方式的效果是一样的，都可以调用一个JSONP接口，前提是JS中已经存在showUser()方法：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建scipt调用JSONP</span></span><br><span class="line">showUserByDynamic:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">      <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">      script.src = <span class="string">"https://localhost:5001/api/user/1?callback=showUser"</span>; </span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(script); </span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>事实上，jQuery中针对JSONP的支持正是基于这种原理，虽然jQuery的时代终将过去，可我相信这些背后的原理永远不会过时。顺着这个思路，我们不妨来看看jQuery中是如何实现JSONP的，以下代码可以在<a href="https://github.com/jquery/jquery/edit/master/src/ajax/script.js" target="_blank" rel="noopener">这里</a>找到：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind script tag hack transport</span></span><br><span class="line">jQuery.ajaxTransport(<span class="string">"script"</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This transport only deals with cross domain or forced-by-attrs requests</span></span><br><span class="line">    <span class="keyword">if</span> (s.crossDomain || s.scriptAttrs) {</span><br><span class="line">        <span class="keyword">var</span> script, callback;</span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            send: <span class="function"><span class="keyword">function</span>(<span class="params">_, complete</span>) </span>{</span><br><span class="line">                script = jQuery(<span class="string">"<script>"</span>).attr(s.scriptAttrs || {}).prop({</span><br><span class="line">                    charset: s.scriptCharset,</span><br><span class="line">                    src: s.url</span><br><span class="line">                }).on(<span class="string">"load error"</span>, callback = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>{</span><br><span class="line">                    script.remove();</span><br><span class="line">                    callback = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (evt) {</span><br><span class="line">                        complete(evt.type === <span class="string">"error"</span> ? <span class="number">404</span> : <span class="number">200</span>, evt.type);</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use native DOM manipulation to avoid our domManip AJAX trickery</span></span><br><span class="line">                <span class="built_in">document</span>.head.appendChild(script[<span class="number">0</span>]);</span><br><span class="line">            },</span><br><span class="line">            abort: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (callback) {</span><br><span class="line">                    callback();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以注意到，它和我们这里的思路一致，即动态创建一个script标签，然后设置其src属性为目标地址，当其加载完成或者加载失败时，就会从页面的DOM节点中删除该标签，因为数据已经通过指定的callback处理过了。jQuery甚至可以替我们生成对应的callback函数，例如，在这里我们可以这样使用jQuery来实现JSONP跨域，具体使用细节这里不再深究：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于$.ajax()调用JSONP</span></span><br><span class="line">showUserByAjax:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">      $.ajax({</span><br><span class="line">            type: <span class="string">"get"</span>,</span><br><span class="line">            url: <span class="string">"http://localhost:5000/api/user/1"</span>,</span><br><span class="line">            dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">            jsonp: <span class="string">"callback"</span>,</span><br><span class="line">            data: <span class="string">""</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">                showUser(user);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="CORS，跨域新标准？"><a href="#CORS，跨域新标准？" class="headerlink" title="CORS，跨域新标准？"></a>CORS，跨域新标准？</h2><p>相对JSONP来说，CORS实现起来就非常简单啦，因为主流的Web框架中几乎都提供了CORS的支持，因为CORS可以实现除了GET以外的譬如POST、PUT等请求，所以，它比JSONP这种”Hack“的方式有更为广阔的适用性，而且随着Web标准化的不断推荐，目前CORS可以说是官方主推的跨域方案。这里我们以.NET Core为例来讲解CORS跨域。</p><p>CORS，即同源资源共享，其实早在ASP.NET时代，这一机制就已经得到了支持，现在我们以.NET Core来讲，无非是希望大家放下历史包袱，在跨平台的新道路上轻装上阵。好了，在.NET Core中我们有两种CORS方案，一种是在Startup类中以全局配置的方式注入到整个中间件管道中，一种是以特性的方式在更小的粒度上控制CORS。这其实和之前配置路由的思路相近，即我们可以配置全局的路由模板，同样可以在Controller和Action级别上定义路由。在这里，我们先定义两种CORS策略，AllowAll和AllowOne，并以此来测试CORS实际的使用效果。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CORS策略：简单粗暴一刀流</span></span><br><span class="line"> services.AddCors(opt=>{</span><br><span class="line">    opt.AddPolicy(<span class="string">"AllowAll"</span>, builder => {</span><br><span class="line">        builder.AllowAnyOrigin();</span><br><span class="line">        builder.AllowAnyHeader();</span><br><span class="line">        builder.AllowAnyMethod();</span><br><span class="line">    });</span><br><span class="line"> });</span><br><span class="line"></span><br><span class="line"><span class="comment">//CORS策略：允许指定域</span></span><br><span class="line">services.AddCors(opt=>{</span><br><span class="line">    opt.AddPolicy(<span class="string">"AllowOne"</span>, builder => {</span><br><span class="line">        builder.WithOrigins(<span class="string">"http://localhost:8888"</span>)</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowAnyMethod()</span><br><span class="line">            .WithExposedHeaders(<span class="string">"X-ASP-NET-Core"</span>,<span class="string">"X-UserName"</span>)</span><br><span class="line">            .AllowCredentials();</span><br><span class="line">    });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>可以注意到，在全局范围内应用AllowAll以后，我们的后端接口将支持来自任意域/端口的跨域访问，这意味着我们之前必须使用JSONP来跨域的地方，现在都可以直接发起跨域请求。到底是不是和我们想得一样呢？答案啊，那必须是肯定的啊！</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">EnableCors(<span class="meta-string">"AllowOne"</span>)</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserController</span>:<span class="title">Controller</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好了，现在我们来测试在UserController上应用局部的CORS请求，在这个实例中，我们指定只有来自localhost:8888的请求可以跨域，为此博主这里用Python临时开了一个服务器，本文中的前端页面，实际上就是运行在这个服务器上的。你知道我想说什么，“人生苦短，我用Python”。因为我们这里返回的是application/json，所以它是一个非简单请求，这里复习一下简单请求与非简单请求。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">MDN</a>中关于CORS的定义，若请求满足所有下述条件，则该请求可视为“简单请求”，简单请求意味着不会触发<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" target="_blank" rel="noopener">CORS 预检请求</a>：</p><ul><li>使用下列方法之一：GET、HEAD、POST。</li><li>Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：Accept、Accept-Language、Content-Language、Content-Type (需要注意额外的限制)、DPR、Downlink、Save-Data、Viewport-Width、Width。</li><li>Content-Type 的值仅限于下列三者之一：text/plain、multipart/form-data、application/x-www-form-urlencoded。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mdn.mozillademos.org/files/14293/simple_req.png" alt="MDN中对简单请求的图解" title>                </div>                <div class="image-caption">MDN中对简单请求的图解</div>            </figure><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求和简单请求相反，即不满足简单请求中任一条件的请求都被成为非简单请求。非简单请求，相对简单请求多了一次<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" target="_blank" rel="noopener">CORS 预检请求</a>。其过程是，首先由浏览器自动发起一个OPTION请求，该请求中携带HTTP头部字段Origin。在本例中，前端页面部署在<a href="http://localhost:8888服务器上，所以，它的Origin字段即为http://localhost:8888。接下来，服务端会返回Access-Control-Allow-Origin/Access-Control-Allow-Headers/Access-Control-Allow-Methods等字段，它对应我们后端定义的AllowOne，注意到这里我们有两个自定义字段X-ASP-NET-Core和X-UserName。在通过预检以后，我们在发起正式请求(本例中为GET请求)的时候，设置后端允许的源，即http://localhost:8888，这样就可以实现基于CORS的跨域请求啦！" target="_blank" rel="noopener">http://localhost:8888服务器上，所以，它的Origin字段即为http://localhost:8888。接下来，服务端会返回Access-Control-Allow-Origin/Access-Control-Allow-Headers/Access-Control-Allow-Methods等字段，它对应我们后端定义的AllowOne，注意到这里我们有两个自定义字段X-ASP-NET-Core和X-UserName。在通过预检以后，我们在发起正式请求(本例中为GET请求)的时候，设置后端允许的源，即http://localhost:8888，这样就可以实现基于CORS的跨域请求啦！</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mdn.mozillademos.org/files/14289/prelight.png" alt="MDN中对非简单请求的图解" title>                </div>                <div class="image-caption">MDN中对非简单请求的图解</div>            </figure><p>所以，我们可以注意到，这里会有一个OPTION请求，即“预检请求”。对于AllowOne这个CORS策略而言，它允许来自localhost:8888的跨域请求，允许的请求方法有GET、PUT、POST和OPTION，客户端必须携带一个自定义HTTP头：X-ASP-NET-Core。当这三个条件满足时，即表示通过“预检”。此时，服务端会返回Access-Control-Allow-Origin/Access-Control-Allow-Methods/Access-Control-Allow-Headers等字段。接下来，浏览器发起的正式请求会带上这些字段，并返回我们所需要的JSON数据，这就是CORS跨域的实际过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1g0nhfm5iprj21h60kcb2d.jpg" alt="OPTION预检请求" title>                </div>                <div class="image-caption">OPTION预检请求</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇文章主要梳理了目前前端跨域的两种主流方案(事实上，在奇葩的前端领域里，最不缺的就是解决方案)，即JSONP和CORS。其中，JSONP本质上是返回可以执行的JS，其基本套路是callback({“foo”:”bar”})，利用了HTML中含src的属性天生具备跨域能力的“漏洞”，是一种相对”hack”的方案，要求预先定义好callback，需要改造后端接口，仅支持最简单的GET请求。而CORS，是比较“官方”的跨域解决方案，其原理是利用HTTP头部字段对请求的来源进行检验，CORS支持除GET以外的请求动词，在使用中间件的情况下，无需修改后端接口，可以在全局或者局部配置CORS跨域策略，对后端开发相对友好。自从接触前端领域，对这个领域里的“黑科技”、“骚操作”吐槽无数次了，不过，前后端分离过程中这些事情还是挺有意思的，对吧？好了，以上就是这篇博客里的全部内容了，欢迎大家吐槽！本文中的示例请从：<a href="https://github.com/qinyuanpei/dotnet-sse/blob/master/server/index.html" target="_blank" rel="noopener">https://github.com/qinyuanpei/dotnet-sse/blob/master/server/index.html</a>这里来获取，谢谢大家！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="跨域" scheme="https://qinyuanpei.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://qinyuanpei.github.io/tags/CORS/"/>
    
      <category term="JSONP" scheme="https://qinyuanpei.github.io/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>基于Server-Sent Events实现服务端消息推送</title>
    <link href="https://qinyuanpei.github.io/posts/3175881014/"/>
    <id>https://qinyuanpei.github.io/posts/3175881014/</id>
    <published>2019-01-18T13:46:44.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>前段时间，为客户定制了一个类似看板的东西，用户可以通过看板了解任务的处理情况，通过APP扫面页面上的二维码就可以领取任务，而当任务被领取以后需要通知当前页面刷新。原本这是一个相对简单的需求，可是因为APP端和PC端是两个不同的Team在维护，换句话说，两个Team各自有一套自己的API接口，前端页面永远无法知道APP到底什么时候扫描了二维码，为此前端页面不得不通过轮询的方式去判断状态是否发生了变化。这种方式会发送大量无用的HTTP请求，因此在最初的版本里，无论是效率还是性能都不能满足业务要求，最终博主采用一种称为服务器推送事件(<strong>Server-Sent Events</strong>)的技术，所以，在今天这篇文章里，博主相和大家分享下关于服务器推送事件(<strong>Server-Sent Events</strong>)相关的内容。</p><h1 id="什么是Server-Sent-Events"><a href="#什么是Server-Sent-Events" class="headerlink" title="什么是Server-Sent Events"></a>什么是Server-Sent Events</h1><p>我们知道，严格地来讲，HTTP协议是无法做到服务端主动推送消息的，因为HTTP协议是一种<strong>请求-响应</strong>模型，这意味着在服务器返回响应信息以后，本次请求就已经结束了。可是，我们有一种变通的做法，即首先是服务器端向客户端声明，然后接下来发送的是流信息。换句话说，此时发送的不是一个一次性的数据包，而是以数据流的形式不断地发送过来，在这种情况下，客户端不会关闭连接，会一直等着服务器端发送新的数据过来，一个非常相似而直观的例子是视频播放，它其实就是在利用流信息完成一次长时间的下载。那么，<strong>Server-Sent Events</strong>(以下简称<strong>SSE</strong>)，就是利用这种机制，使用流信息像客户端推送信息。</p><p>说到这里，可能大家会感到疑惑：WebSocket不是同样可以实现服务端向客户端推送信息吗？那么这两种技术有什么不一样呢？首先，WebSocket和SSE都是在建立一种浏览器与服务器间的通信通道，然后由服务器向浏览器推送信息。两者最为不同的地方在于，WebSocket建立的是一个全双工通道，而SSE建立的是一个单工通道。所谓单工和双工，是指数据流动的方向上的不同，对WebSocket而言，客户端和服务端都可以发送信息，所以它是双向通信；而对于SSE而言，只有服务端可以发送消息，故而它是单向通信。从下面的图中我们可以看得更为直观，在WebSocket中数据”有来有往”，客户端既可以接受信息亦可发送信息，而在SSE中数据是单向的，客户端只能被动地接收来自服务器的信息。所以，这两者在通信机制上不同到这里已经非常清晰啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzf5w39987j20se0dv77u.jpg" alt="WebSocket与SSE对比" title>                </div>                <div class="image-caption">WebSocket与SSE对比</div>            </figure><h2 id="SSE服务端"><a href="#SSE服务端" class="headerlink" title="SSE服务端"></a>SSE服务端</h2><p>下面我们来看看SSE是如何通信的，因为它是一个单工通道的协议，所以协议定义的都是在服务端完成的，我们就从服务端开始吧！协议规定，服务器向客户端发送的消息，必须是UTF-8编码的，并且提供如下的HTTP头部信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></tbody></table></figure><p>这里出现了一个一种新的MIME类型，<strong>text/event-stream</strong>。协议规定，第一行的Content-Type必须是<strong>text/event-stream</strong>，这表示服务端的数据是以信息流的方式返回的，Cache-Control和Connection两个字段和常规的HTTP一致，这里就不再展开说啦！OK，现在客户端知道这是一个SSE信息流啦，那么客户端怎么知道服务端发送了什么消息呢？这就要说到SSE的消息格式，在SSE中消息的基本格式是：<br></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">field</span>]: <span class="link">value\n</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>其中，field可以取四个值，它们分别是：<strong>data</strong>、<strong>event</strong>、<strong>id</strong>、<strong>retry</strong>，我们来一起看看它们的用法。</p><p><strong>data</strong>字段表示数据内容，下面的例子展示SSE中的一行和多行数据，可以注意到，当数据有多行时，可以用\n作为每一行的结尾，只要保证最后一行以\n\n结尾即可。</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">：这是一行数据内容</span><br><span class="line"><span class="symbol">data:</span> SSE给你发了一行消息\n\n</span><br><span class="line">：这是多行数据内容</span><br><span class="line"><span class="symbol">data:</span> {\n</span><br><span class="line"><span class="symbol">data:</span> <span class="string">"foo"</span>: <span class="string">"foolish"</span>,\n</span><br><span class="line"><span class="symbol">data:</span> <span class="string">"bar"</span>, <span class="number">2333</span>\n</span><br><span class="line"><span class="symbol">data:</span> }\n\n</span><br></pre></td></tr></tbody></table></figure><p><strong>event</strong>字段表示自定义事件，默认为message，在浏览器中我们可以用<strong>addEventListener()</strong>来监听响应的事件，这正是为什么SSE被称为服务器推送事件，因为我们在这里既可以发送消息，同样可以发送事件。<br></p><figure class="highlight taggerscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">: GameStart事件</span><br><span class="line">event: GameStart<span class="symbol">\n</span></span><br><span class="line">data: 敌军还有30秒到达战场<span class="symbol">\n</span><span class="symbol">\n</span></span><br><span class="line"></span><br><span class="line">data: Double Kill<span class="symbol">\n</span><span class="symbol">\n</span></span><br><span class="line"></span><br><span class="line">: GameOver事件</span><br><span class="line">event: GaneOver<span class="symbol">\n</span></span><br><span class="line">data: You Win！<span class="symbol">\n</span><span class="symbol">\n</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>id </strong>字段是一个数据标识符，相当于我们可以给每一条消息一个编号。</p><figure class="highlight taggerscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id: 1<span class="symbol">\n</span></span><br><span class="line">data: 敌军还有30秒到达战场<span class="symbol">\n</span><span class="symbol">\n</span></span><br><span class="line">id: 2<span class="symbol">\n</span></span><br><span class="line">data: Double Kill<span class="symbol">\n</span><span class="symbol">\n</span></span><br><span class="line">id: 3<span class="symbol">\n</span></span><br><span class="line">data: You Win！<span class="symbol">\n</span><span class="symbol">\n</span></span><br></pre></td></tr></tbody></table></figure><p><strong>retry</strong>字段可以指定浏览器重新发起连接的时间间隔，所以，SSE天生就支持断线重连机制。<br></p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">retry:</span> <span class="number">10000</span>\n</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="SSE客户端"><a href="#SSE客户端" class="headerlink" title="SSE客户端"></a>SSE客户端</h2><p>SSE目前是HTML5标准之一，所以，目前主流的浏览器(<strong>除了IE和Edge以外</strong>)都天然支持这一特性，这意味着我们不需要依赖<strong>前端娱乐圈</strong>推崇的各种工具链，就可以快速地使用SSE来投入开发。这里需要使用地是<a href="https://developer.mozilla.org/zh-CN/Server-sent_events/EventSource" target="_blank" rel="noopener">EventSource</a>对象，我们从下面这个例子开始了解：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'EventSource'</span> <span class="keyword">in</span> <span class="built_in">window</span>) {</span><br><span class="line">  <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(url, { <span class="attr">withCredentials</span>: <span class="literal">true</span> });</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* open事件回调函数 */</span></span><br><span class="line">  source.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SSE通道已建立...'</span>);</span><br><span class="line">  };</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* message事件回调函数 */</span></span><br><span class="line">  source.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(evt.data);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* error事件回调函数 */</span></span><br><span class="line">  source.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SSE通道发生错误'</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 自定义事件回调 */</span></span><br><span class="line">  source.addEventListener(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// handle message</span></span><br><span class="line">  },<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭SSE */</span></span><br><span class="line">  source.close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>和各种各样的HTML5接口一样，我们需要判断当前的浏览器环境是否支持SSE。建立SSE只需要后端提供一个Url即可，当存在跨域时，我们可以打开第二个参数：<strong>withCredentials</strong>，这样SSE会在建立通道时携带Cookie。我们通过实例化后的source对象来判断通道是否建立，该对象有一个重要的属性：<strong>readyState</strong>。当它的取值为0时，表示连接还未建立，或者断线正在重连；当它的取值为1时，表示连接已经建立，可以接受数据；当它的取值为2时，表示连接已断，且不会重连。</p><p>好了，当SSE被成功建立以后，首先会触发open事件。这里介绍下SSE中的关键事件，即open、message和error，我们可以分别通过<strong>onopen</strong>、<strong>onmessage</strong>和<strong>onerror</strong>这三个回调函数来监听相应的事件。对于SSE而言，它是一个单工通道，客户端不能主动向服务端发送信息，所以，一旦建立了SSE通道，客户端唯一需要关注的地方就是<strong>onmessage</strong>这个回调函数，因为客户端只需要负责处理消息即可，甚至我们可以连<strong>onerror</strong>都不用关注，因为SSE自带断线重连机制，当然你可以选择在发生错误的时候关掉连接，此时你需要<strong>close()</strong>方法。</p><p>我们在上面提到，SSE在服务端可以定义自定义事件，那么，在浏览器中我们该如何接收这些自定义事件呢？这当然要提到无所不能的<strong>addEventListener</strong>，在人肉操作DOM的jQuery时代，jQuery中提供的大量API在协调不同浏览器间差异的同时，让我们离这些底层的知识越来越远，时至今日，当<strong>erySelector/querySelectorAll</strong>完全可以替换jQuery的选择器的时候，我们是不是可以考虑重新把某些东西捡起来呢？言归正传，在SSE中，我们只需要像注册普通事件一样，就可以完成对自定义事件的监听，只要客户端和服务端定好消息的协议即可。</p><h1 id="在-NET中集成Server-Sent-Events"><a href="#在-NET中集成Server-Sent-Events" class="headerlink" title="在.NET中集成Server-Sent Events"></a>在.NET中集成Server-Sent Events</h1><p>OK，说了这么多，大家一定感觉有一个鲜活的例子会比较好一点，奈何<a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">官方</a>提供的示例都是PHP的，难道官方默认PHP是世界上最好的编程语言了吗？所谓<strong>万变不离其宗”</strong>，下面我们以.NET为例来快速集成Server-Sent Events，这里需要说明的是，博主下面的例子采用ASP.NET Core 2.0版本编写，首先，我们建一个名为SSEController的控制器，在默认的Index()方法中，按照SSE规范，我们首先组织HTTP响应头，然后发送了一个名为SSE_Start的自定义事件，接下来，我们每隔10秒钟给客户端发送一条消息，请原谅我如此敷衍的Sleep()：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SSEController</span> : <span class="title">Controller</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">    <span class="comment">//组织HTTP响应头</span></span><br><span class="line">    Response.Headers.Add(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>);</span><br><span class="line">    Response.Headers.Add(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">    Response.Headers.Add(<span class="string">"Content-Type"</span>, <span class="string">"text/event-stream"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送自定义事件</span></span><br><span class="line">        <span class="keyword">var</span> message = BuildSSE(<span class="keyword">new</span> { Content = <span class="string">"SSE开始发送消息"</span>, Time = DateTime.Now }, <span class="string">"SSE_Start"</span>);</span><br><span class="line">        Response.Body.Write(message, <span class="number">0</span>, message.Length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每隔10秒钟向客户端发送一条消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        {</span><br><span class="line">            message = BuildSSE(<span class="keyword">new</span> { Content = <span class="string">$"当前时间为<span class="subst">{DateTime.Now}</span>"</span> });</span><br><span class="line">            Response.Body.Write(message, <span class="number">0</span>, message.Length);</span><br><span class="line">            Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们提到，SSE的数据是按照一定的格式，由id、event、data和retry四个字段构成的，那么，织消息格式的代码我们放在了<strong>BuildSSE()</strong>方法中，我们来一起看看它的实现：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] BuildSSE<TMessage>(TMessage message, <span class="keyword">string</span> eventName = <span class="literal">null</span>, <span class="keyword">int</span> retry = <span class="number">30000</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.Append(<span class="string">$"id:<span class="subst">{Guid.NewGuid().ToString(<span class="string">"N"</span>)}</span>\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(eventName))</span><br><span class="line">        builder.Append(<span class="string">$"event:<span class="subst">{eventName}</span>\n"</span>);</span><br><span class="line">    builder.Append(<span class="string">$"retry:<span class="subst">{retry}</span>\n"</span>);</span><br><span class="line">    builder.Append(<span class="string">$"data:<span class="subst">{JsonConvert.SerializeObject(message)}</span>\n\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> Encoding.UTF8.GetBytes(builder.ToString());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到，完全按照SSE规范来定义的，这里每次生成一个新的GUID来作为消息的ID，客户端断线后重连的间隔为30秒，默认发送的是<strong>“消息”</strong>，当指定eventName参数时，它就表示一个自定义事件，这里我们使用JSON格式来传递信息。好了，这样我们就完成了服务端的开发，怎么样，是不是感觉非常简单呢？我们先让它跑起来，下面着手来编写客户端，这个就非常简单啦！<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><!DOCTYPE html></span><br><span class="line"><html></span><br><span class="line"><body></span><br><span class="line"><h1>DotNet-SSE<<span class="regexp">/h1></span></span><br><span class="line"><span class="regexp"><div id="result"></</span>div></span><br><span class="line"><script></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'EventSource'</span> <span class="keyword">in</span> <span class="built_in">window</span>) {</span><br><span class="line">  <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost:5000/api/SSE/'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* open事件回调函数 */</span></span><br><span class="line">  source.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML+= <span class="string">"SSE通道已建立...<br/>"</span>;</span><br><span class="line">  };</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* message事件回调函数 */</span></span><br><span class="line">  source.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>{</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML+= <span class="string">"Message: "</span> + event.data + <span class="string">"<br/>"</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* error事件回调函数 */</span></span><br><span class="line">  source.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>{</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML+= <span class="string">"SSE通道发生错误<br/>"</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* SSE_Start事件回调 */</span></span><br><span class="line">  source.addEventListener(<span class="string">'SSE_Start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML += <span class="string">"SSE_Start: "</span> + event.data + <span class="string">"<br/>"</span>;</span><br><span class="line">  },<span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"><<span class="regexp">/script></span></span><br><span class="line"><span class="regexp"></</span>body></span><br><span class="line"><<span class="regexp">/html></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>此时，不需要任何<strong>现代前端</strong>方面的技术，我们直接打开浏览器，就可以看到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzfbt5m898g20jk06jdfw.gif" alt="SSEDemo" title>                </div>                <div class="image-caption">SSEDemo</div>            </figure><p>更为直观的，我们可以通过Chrome开发者工具观察到实际的请求情况，相比普通的HTTP请求，SSE会出现一个名为EventStream的选项卡，这是因为我们在服务端设置的Content-Type为<strong>text/event-stream</strong>的缘故，可以注意到，我们定义的id(GUID)会在这里显示出来：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzfc3ik2l2j20ww07kgmo.jpg" alt="有点与众不同的SSE" title>                </div>                <div class="image-caption">有点与众不同的SSE</div>            </figure><h1 id="同类技术优劣对比"><a href="#同类技术优劣对比" class="headerlink" title="同类技术优劣对比"></a>同类技术优劣对比</h1><p>OK，这篇文章写到这里，相信大家已经对SSE有了一个比较具体的概念，那么，我们不妨来梳理下相关的同类技术。一路走过来，我们大体上经历了<strong>(短)轮询</strong>、<strong>长轮询/Comet</strong>、<strong>SSE</strong>和<strong>WebSocket</strong>。</p><p><strong>(短)轮询</strong>这个比较容易理解了，它从本质上来讲，就是由客户端定时去发起一个HTTP请求，这种方式是一种相对尴尬的方式，为什么这样说呢？因为时间间隔过长则无法保证数据的时效性，而时间间隔过短则会发送大量无用的请求，尤其是当客户端数量比较多的时候，这种方式很容易耗尽服务器的连接数。</p><p><strong>而长轮询</strong>则是(短)轮询的一个变种，它和(短)轮询最大的不同在于，服务端在接收到请求以后，并非立即进行响应，而是先将这个请求挂起，直到服务器端数据发生变化时再进行响应。所以，一个明显的优势是，它相对地减少了大量不必要的HTTP请求，那么，它是不是就完美无暇了呢？当然不是，因为服务端会将客户端发来的请求挂起，因此在挂起的那些时间里，服务器的资源实际上是被浪费啦！</p><p>严格地说，<strong>SSE</strong>并不是一门新技术，为什么这样说呢？因为它和我们基于HTTP长连接的Push非常相似。这里又提到一个新概念，HTTP长连接，其实，这个说法病逝非常严谨，因为我们知道HTTP最早就是一个请求-响应模型，直到HTTP1.1中增加了持久连接，即Connection:keep-alive的支持。所以，我们这里说的长连接、短链接实际上都是指TCP的长连接还是短连接，换句话说，它和客户端没有关系，只要服务端支持长连接，那么在某个时间段内的TCP连接实际上复用的，进而就能提高HTTP请求性能，曾经我们不是还用iframe做过长连接吗？</p><p><strong>WebSocket</strong>作为构建实时交互应用的首选技术，博主曾经在<a href="https://qinyuanpei.github.io/posts/3269605707/">《基于WebSocket和Redis实现Bilibili弹幕效果》</a>一文中有所提及，WebSocket相比前面这些技术，最大的不同在于它拥有专属的通信通道，一旦这个通道建立，客户端和服务端就可以互相发送消息，它沿用了我们传统的Socket通讯的概念和原理，变被动为主动，无论是客户端还是服务端，都不必再被动地去<strong>“拉”</strong>或者<strong>“推”</strong>。在这个过程中，出现了像SignalR/SocketIO等等的库，它们主打的兼容性和降级策略，曾经一度让我们感到亲切，不过随着WebSocket标准化的推进，相信这些最终都会被原生API所替代吧，也许是有生之年呢？谁知道未来是什么样子呢？</p><p>下面给出针对以上内容的<strong>“简洁”</strong>版本：</p><table><thead><tr><th></th><th>（短)轮询</th><th>长轮询/Comet</th><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td>浏览器支持</td><td>全部</td><td>全部</td><td>除IE/Edge</td><td>现代浏览器</td></tr><tr><td>是否独立协议</td><td>HTTP</td><td>HTTP</td><td>HTTP</td><td>WS</td></tr><tr><td>是否轻量</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>断线重连</td><td>否</td><td>否</td><td>是</td><td>否</td></tr><tr><td>负载压力</td><td>占用内存/请求数</td><td>同（短)轮询</td><td>一般</td><td>同SSE</td></tr><tr><td>数据延迟</td><td>取决于请求间隔</td><td>同（短)轮询</td><td>实时</td><td>实时</td></tr></tbody></table><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>正如本文一开始所写，博主使用SSE是因为业务上的需要，在经历了轮询带来的性能问题以后，博主需要一款类似WebSocket的东西，来实现服务端主动向客户端推送消息，究其原因，是因为浏览器永远都不知道，App到底什么时候会扫描二维码，所以，从一开始我们试图让网页去轮询的做法，本身就是不太合理的。那么，为什么没有用WebSocket呢？因为WebSocket需要一点点<strong>框架</strong>层面的支持，所以，我选择了更为轻量级的SSE，毕竟，这比让其它Team的同事去调整他们的后端接口要简单的多。我之前参与过一部分WebSocket相关的项目，我深切地感受到，除了在浏览器的兼容性问题以外，因为WebSocket使用的是独有的WS协议，所以，我们常规的API网关其实在这方面支持的都不是很好，更不用说鉴权、加密等等一系列的问题啦，而SSE本身是基于HTTP协议的，我们目前针对HTTP的各种基础设施，都可以直接拿过来用，这应该是我最大的一点感悟了吧，好了，这篇文章就是这样啦，谢谢大家，新的一年注定要重新开始的呢……</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank" rel="noopener">IBM - Comet：基于 HTTP 长连接的“服务器推”技术</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">Mozilla - 使用服务器发送事件</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">阮一峰 - Server-Sent Events 教程</a></li><li><a href="https://blog.csdn.net/baidu_38990811/article/details/79172163" target="_blank" rel="noopener">呆呆_小茗 - Ajax轮询，Ajax长轮询和Websocket(详细使用)</a></li><li><a href="https://www.cnblogs.com/hrhguanli/p/3818452.html" target="_blank" rel="noopener"> hrhguanli - HTTP长连接和短连接</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="WebSocket" scheme="https://qinyuanpei.github.io/tags/WebSocket/"/>
    
      <category term="SSE" scheme="https://qinyuanpei.github.io/tags/SSE/"/>
    
      <category term="后端" scheme="https://qinyuanpei.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>博客图片迁移折腾记</title>
    <link href="https://qinyuanpei.github.io/posts/3444626340/"/>
    <id>https://qinyuanpei.github.io/posts/3444626340/</id>
    <published>2019-01-18T09:27:35.000Z</published>
    <updated>2019-05-10T10:39:36.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  去年国庆的时候，七牛官方开始回收测试域名，这直接导致博客中大量图片出现无法访问的情况，虽然博主第一时间启用了新的域名：<a href="https://blog.yuanpei.me" target="_blank" rel="noopener">https://blog.yuanpei.me</a>，可是因为七牛官方要求域名必须备案，所以，这件事情一直耽搁着没有往下进行。至于为什么会一直拖到2019年，我想大家都能猜到一二，没错，我就是懒得去弄域名备案这些事情<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。最近花了点时间，把博客里的图片从七牛和CSDN迁移了出来，所以，今天这篇博客，主要想和大家分享下这个折腾的过程，如果能帮助到和我一样，因为七牛官方回收了域名而无法导出图片的朋友，在下开心之至。虽然今天没有回望过去，没有给新的一年立flag，就如此平淡地过渡到了2019年，可或许这才是生活本来的样子吧！</p><p>  七牛的测试域名被官方回收了以后，我们有两种思路去导出这些图片，其一，是临时像官方提工单申请一个测试域名，这样在测试域名被回收前，我们可以直接使用官方提供的<a href="https://developer.qiniu.com/kodo/tools/qrsctl" target="_blank" rel="noopener">qrsctl</a>或者<a href="https://developer.qiniu.com/kodo/tools/qshell" target="_blank" rel="noopener">qshell</a>工具进行批量导出，因为此时我们可以直接在配置文件里配置测试域名，具体可以参考这篇文章：<a href="https://www.jianshu.com/p/309709f7bfe4" target="_blank" rel="noopener">跑路之后七牛图片如何导出备份至本地</a>，甚至你可以直接到七牛的管理控制台手动下载，可这样就一点都不极客了对吗？我们是一生追求做极客的人好伐。其二，同样是借助官方提供的<a href="https://developer.qiniu.com/kodo/tools/qshell" target="_blank" rel="noopener">qshell</a>工具，因为没有域名，我们没有办法批量导出，可是工具中提供了两个非常有用的命令，它们分别是：<strong>qshell listbucket</strong>、<strong>qshell get</strong>。通过这两个命令，我们就可以列举出指定bucket中的文件以及下载指定文件，所以，这就是我们的第一步，首先把图片从七牛那里导出到本地。以博主的<strong>blogspace</strong>为例：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qshell account <ak> <sk> 'qinyuanpei@163.com' /* 请使用你的ak/sk，谢谢 */</span><br><span class="line">qshell listbucket blogspace</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzakc094mzj20zb0a5qv5.jpg" alt="使用listbucket列举指定bucket内文件" title>                </div>                <div class="image-caption">使用listbucket列举指定bucket内文件</div>            </figure><p>  事实上，通过第一列的Key，即文件名，我们就可以下载该资源到本地，因为七牛实际上是采用对象存储的方式来组织资源的，这里我们以第一张图片<strong>05549344-BF85-4e8c-BCBC-1F63DFE80E43.png</strong>为例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qshell get blogspace 05549344-BF85-4e8c-BCBC-1F63DFE80E43.png</span><br></pre></td></tr></tbody></table></figure><p>  默认情况下，该图片会下载到当前目录下，本地文件和远程文件名保持一致。当然，我们还可以通过-o参数来指定输出文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzakdbeka4j20fo0ex4qp.jpg" alt="使用get命令下载指定文件" title>                </div>                <div class="image-caption">使用get命令下载指定文件</div>            </figure><p>  好了，有了这个基础，我们就可以着手博客图片的迁移啦。博主最初的想法是，先获取到指定bucket下的全部文件，然后再对结果进行拆分，循环执行qshell get命令，可惜再PowerShell下并没有类似grep的命令，所以，这个想法放弃。其实，你仔细观察七牛图片外链的格式就会发现，除了域名部分以外，剩下的就是该文件在bucket里对应的key啦，所以，博主的想法开始从Markdown文件入手，最终我们的思路是，解析博客对应的Markdown文件，通过正则匹配所有的图片链接，截取出图片的文件名并通过qshell下载到本地。人生苦短，我用Python。具体写出来，大概是下面这个样子：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(root,ak,sk,account,bucket)</span>:</span></span><br><span class="line">    files = []</span><br><span class="line">    children = os.listdir(root)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">        path = os.path.join(root,child)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">            files.append(path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        links = []</span><br><span class="line">        newContent = <span class="string">''</span></span><br><span class="line">        <span class="keyword">with</span> open(file,<span class="string">'rt'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            content = fp.read()</span><br><span class="line">            matches = re.compile(<span class="string">'!\\[.*?\\]\\((.*?)\\)'</span>).findall(content) </span><br><span class="line">            <span class="keyword">if</span>(len(matches)><span class="number">0</span>):</span><br><span class="line">                links.extend(matches)</span><br><span class="line">            <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">                fileKey = link.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'http://img.blog.csdn.net'</span> <span class="keyword">in</span> link):</span><br><span class="line">                    newLink = sync_csdn(link)</span><br><span class="line">                    newContent = content.replace(link,newLink)</span><br><span class="line">                <span class="keyword">elif</span>(<span class="string">'clouddn.com'</span> <span class="keyword">in</span> link):</span><br><span class="line">                    newLink = sync_qiniu(ak,sk,account,bucket,fileKey)</span><br><span class="line">                    newContent = content.replace(link,newLink)</span><br><span class="line">        <span class="keyword">if</span>(newContent != <span class="string">''</span> <span class="keyword">and</span> len(links) > <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">with</span> open(file,<span class="string">'wt'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                fp.write(newContent)</span><br><span class="line">            print(<span class="string">'已自动完成对{0}中图片链接的自动更新'</span>.format(file))</span><br></pre></td></tr></tbody></table></figure><p></p><p>  因为博主的博客，在此之前(指2012年~2018年，暴露年龄啦<strong>ORZ</strong>)，主要都在：<a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="noopener">https://blog.csdn.net/qinyuanpei</a>这里维护，所以，这次就一并通过脚本处理啦。这部分我们这里不用太关注，对于托管在七牛上的图片资源，我们通过<strong>sync_qiniu</strong>方法来完成同步：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync_qiniu</span><span class="params">(ak,sk,account,bucket,fileKey)</span>:</span></span><br><span class="line">    os.system(<span class="string">'qshell account {0} {1} {2} -w'</span>.format(ak,sk,account))</span><br><span class="line">    outfile = root + <span class="string">"\\download\\blogspace\\"</span> + fileKey</span><br><span class="line">    outfile = outfile.replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">if</span>(os.path.exists(outfile)):</span><br><span class="line">        os.remove(outfile)</span><br><span class="line">    os.system(<span class="string">'qshell get {0} {1} -o {2}'</span>.format(bucket,fileKey,outfile))</span><br><span class="line">    print(<span class="string">"同步七牛图片{0}完成"</span>.format(fileKey))</span><br><span class="line">    pid = upload(outfile)</span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="literal">None</span>):</span><br><span class="line">        print(<span class="string">'同步后的图片链接为:'</span> + upload(outfile))</span><br><span class="line">        <span class="keyword">return</span> pid</span><br></pre></td></tr></tbody></table></figure><p>  博客中的图片导出到本地以后，我们就要开始考虑第二个问题，这些图片要放到哪里去，直接和博客放在一起，估计早晚会突破Github单个仓库1G的限制。七牛增加域名备案的限制以后，像又拍云这种同类产品必须会跟进这个<strong>feature</strong>，原因嘛，我想大家都知道不必多说。大概考虑了像阿里云和腾讯云的OSS类产品，因为我司的产品最近正在着手从自有的FTP上切换到阿里云的OSS上，主要是考虑服务器的维护成本，但对博主这样的个人用户而言，这类OSS产品实在太贵了，最终，博主选择国内某知名社交平台提供的<strong>“图床服务”</strong>。参考这篇文章：<a href="https://segmentfault.com/a/1190000008490501" target="_blank" rel="noopener">PHP上传图片到微博图床</a>，最终实现了一个简洁(陋)的版本：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(src_file)</span>:</span></span><br><span class="line">    url = <span class="string">"http://picupload.service.weibo.com/interface/pic_upload.php"</span></span><br><span class="line">    fileExt = src_file.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span>(fileExt == <span class="string">'png'</span>):</span><br><span class="line">        fileExt = <span class="string">'jpg'</span></span><br><span class="line">    timestamp = str(int(time.time()))</span><br><span class="line">    mimes = {<span class="string">"gif"</span>:<span class="string">'image%2Fgif'</span>,<span class="string">'jpg'</span>:<span class="string">'image%2Fjpeg'</span>,<span class="string">'jpeg'</span>:<span class="string">'image%2Fjpeg'</span>}</span><br><span class="line">    querystring = {<span class="string">"mime"</span>:mimes[fileExt],<span class="string">"data"</span>:<span class="string">"base64"</span>,<span class="string">"url"</span>:<span class="string">"0"</span>,<span class="string">"markpos"</span>:<span class="string">"1"</span>,<span class="string">"logo"</span>:<span class="string">""</span>,<span class="string">"nick"</span>:<span class="string">"0"</span>,<span class="string">"marks"</span>:<span class="string">"1"</span>,<span class="string">"app"</span>:<span class="string">"miniblog"</span>,<span class="string">"cb"</span>:<span class="string">"http://weibo.com/aj/static/upimgback.html?_wv=5"</span>,<span class="string">"callback"</span>:<span class="string">"STK_ijax_"</span> + timestamp}</span><br><span class="line">    headers = {</span><br><span class="line">        <span class="string">'Cookie'</span>: <span class="string">"在这里填入Cookie"</span>,</span><br><span class="line">    }</span><br><span class="line">    files = {<span class="string">'pic1'</span>:open(src_file,<span class="string">'rb'</span>).read()}</span><br><span class="line">    response = requests.request(<span class="string">"POST"</span>, url, headers=headers, params=querystring,files=files)</span><br><span class="line">    <span class="keyword">if</span>(response.status_code == <span class="number">200</span>):</span><br><span class="line">        result = re.sub(<span class="string">r"<meta.*</script>"</span>, <span class="string">""</span>, response.text, flags=re.S)</span><br><span class="line">        image_result = json.loads(result)</span><br><span class="line">        image_id = image_result.get(<span class="string">'data'</span>).get(<span class="string">'pics'</span>).get(<span class="string">'pic_1'</span>).get(<span class="string">'pid'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'https://ws1.sinaimg.cn/large/{0}.{1}'</span>.format(image_id,fileExt)</span><br></pre></td></tr></tbody></table></figure><p></p><p>  如果你现在访问我的博客，大概就会发现，之前那些无法显示的图片，现在基本上都可以显示啦，而我所做的事情，就是执行这些Python脚本，让它帮我完成从图片下载、上传再到替换链接的所有事情。感觉配合Typora在插入图片时可以拷贝到指定目录的功能，完全可以支持本地图片链接自动替换的功能，这样子以后写博客的时候，只要插入准备后的本地图片就好了，真是想想都觉得美好呢？我和一位朋友分享了这个想法，他觉得<strong>“微博图床”</strong>并不靠谱，这样说起来，它最不好的地方大概就是没有办法保留原有的文件名，所以，万一将来有一天它挂了，你要恢复这些图片会比较麻烦，一个好的建议是维护一个数据库，譬如SQLite足矣，把本地文件名和远程文件名对应起来，甚至你可以把图片的Base64编码存储到数据库里呢，对吧？</p><p>  好了，以上就这2019年第一篇碎碎念啦，为了证明我的思维的确是跳跃的，最后的最后，强烈地向大家安利两个图床工具：<a href="https://github.com/xCss/WeiBox" target="_blank" rel="noopener">WeiBox</a>、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，它们都支持微博图床，所以，你猜我是用哪个工具上传这篇文章里地图片的呢？当然是脚本啊，那样不就不那么极客了嘛，我们是一生追求做极客的人好伐！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/270c.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/270c.png?v8">✌</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="独立博客" scheme="https://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="七牛" scheme="https://qinyuanpei.github.io/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图床" scheme="https://qinyuanpei.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>基于EF的数据库主从复制、读写分离实现</title>
    <link href="https://qinyuanpei.github.io/posts/2418566449/"/>
    <id>https://qinyuanpei.github.io/posts/2418566449/</id>
    <published>2018-10-18T08:41:08.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  各位朋友，大家好，欢迎大家关注我的博客，我是Psyne，我的博客地址是<a href="https://blog.yuanpei.me" target="_blank" rel="noopener">https://blog.yuanpei.me</a>。在上一篇博客中，我们提到了通过DbCommandInterceptor来实现EF中SQL针对SQL的“日志”功能。我们注意到，在这个拦截器中，我们可以获得当前数据库的上下文，可以获得SQL语句中的参数，更一般地，它具备“AOP”特性的扩展能力，可以在执行SQL的前后插入相应的动作，这就有点类似数据库中触发器的概念了。今天，我们主要来说一说，基于EF实现数据库主从复制和读写分离，希望这个内容对大家有所帮助。</p><h1 id="主从复制-＆-读写分离"><a href="#主从复制-＆-读写分离" class="headerlink" title="主从复制 ＆ 读写分离"></a>主从复制 ＆ 读写分离</h1><p>  首先，我们先来了解一个概念：主从复制。那么，什么是主从复制呢？通常，在只有一个数据库的情况下，这个数据库会被称为<strong>主数据库</strong>。所以，当有多个数据库存在的时候，数据库之间就会有主从之分，而那些和主数据库完全一样的数据库就被称为<strong>从数据库</strong>，所以，<strong>主从复制其实就是指建立一个和主库完全一样的数据库环境</strong>。</p><p>  那么，我们为什么需要主从复制这种设计呢？我们知道，主数据库一般用来存储实时的业务数据，因此如果主数据库服务器发生故障，从数据库可以继续提供数据服务，这就是主从复制的优势之一，<strong>即作为数据提供灾备能力</strong>。其次，从业务扩展性上来讲，互联网应用的业务增长速度普遍较高，随着业务量越来越大，I/O的访问频率越来越高，在单机磁盘无法满足性能要求的情况下，<strong>通过设置多个从数据库服务器，可以降低磁盘的I/O访问频率，进而提高单机磁盘的读写性能</strong>。从业务场景上来讲，数据库的性能瓶颈主要在读即查询上，<strong>因此将读和写分离，能够让数据库支持更大的并发，这对优化前端用户体验很有意义</strong>。</p><p>  通常来讲，不同的数据库都在数据库层面上实现了主从复制，各自的实现细节上可能会存在差异，譬如SQLServer中可以通过“发布订阅”来配置主从复制的策略，而Oracle中可以通过DataGurd来实现主从复制，甚至你可以直接把主库Dump出来再导入到从库。博主没有能力详细地向大家介绍它们的相关细节，可博主相信“万变不离其宗”的道理，这里我们以MySQL为例，因为它在互联网应用中更为普遍，虽然坑会相应地多一点:)……</p><p>  MySQL中有一种最为重要的日志binlog，即二进制日志，它记录了所有的DDL和DML(除查询以外)语句，通过这些日志，不仅可以作为灾备时的数据恢复，同样可以传递给从数据库来达到数据一致的目的。具体来讲，对于每一个主从复制的连接，都有三个线程，即拥有多个从库的主库为每一个从库创建的<strong>binlog输出线程</strong>，从库自身的<strong>IO线程</strong>和<strong>SQL线程</strong>：</p><ul><li>当从库连接到主库时，主库就会创建一个线程然后把binlog发送到从库，这是binlog输出线程。</li><li>当从库执行START SLAVER以后，从库会创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件(其中包括relay log文件)。</li><li>从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</li></ul><h1 id="EF中主从复制的实现"><a href="#EF中主从复制的实现" class="headerlink" title="EF中主从复制的实现"></a>EF中主从复制的实现</h1><p>  虽然从数据库层面上做主从复制会更简单一点，可在很多时候，这些东西其实更贴近DBA的工作，而且不同数据库在操作流程上还都不一样，搞这种东西注定不能成为“通用”的知识领悟。对开发人员来说，EF和Dapper这样的ORM更友好一点，如果可以在ORM层面上做触发器和存储过程，可能SQL看起来就没有那么讨厌了吧！博主的公司因为要兼顾主流的数据库，所以，不可能在数据库层面上去做主从复制，最终我们是通过EF来实现主从复制。</p><p>  其实，讲了这么多主从复制的原理，对我们来说，这篇文章的实现则是非常简单的。因为通过DbCommandInterceptor我们能拦截到SQL命令，所以，只要是Select命令全部走从库，Insert/Update/Delete全部走主库，这样就实现了读写分离。怎么样，是不是感觉相当简单啊！当然，前提是要准备好主从库的屋里环境，这些就让DBA去折腾吧(逃。好了，下面一起来看具体代码，首先我们定义一个主从库管理类MasterSlaveManager：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MasterSlaveManager</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MasterSalveConfig _config => LoadConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加载主从配置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"></summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><param name="fileName"></span>配置文件<span class="doctag"></param></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><returns></span><span class="doctag"></returns></span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MasterSalveConfig <span class="title">LoadConfig</span>(<span class="params"><span class="keyword">string</span> fileName = <span class="string">"masterslave.config.json"</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(fileName)) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="keyword">string</span>.Format(<span class="string">"配置文件{0}不存在"</span>, fileName));</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.DeserializeObject<MasterSalveConfig>(File.ReadAllText(fileName));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 切换到主库</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"></summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><param name="command"></span>DbCommand<span class="doctag"></param></span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SwitchToMaster</span>(<span class="params">DbCommand command, <span class="keyword">string</span> serverName = <span class="string">""</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> masterServer = <span class="keyword">string</span>.IsNullOrEmpty(serverName) ? </span><br><span class="line">            _config.Masters.FirstOrDefault() : _config.Masters.FirstOrDefault(e => e.ServerName == serverName);</span><br><span class="line">        <span class="keyword">if</span> (masterServer == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"未配置主库服务器或者服务器名称不正确"</span>);</span><br><span class="line">        <span class="comment">//切换数据库连接</span></span><br><span class="line">        ChangeDbConnection(command, masterServer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 切换到从库</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"></summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><param name="command"></span>DbCommand<span class="doctag"></param></span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SwitchToSlave</span>(<span class="params">DbCommand command, <span class="keyword">string</span> serverName = <span class="string">""</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> salveServer = <span class="keyword">string</span>.IsNullOrEmpty(serverName) ?</span><br><span class="line">             _config.Slaves.FirstOrDefault() : _config.Slaves.FirstOrDefault(e => e.ServerName == serverName);</span><br><span class="line">        <span class="keyword">if</span> (salveServer == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"未配置从库服务器或者服务器名称不正确"</span>);</span><br><span class="line">        <span class="comment">//切换数据库连接</span></span><br><span class="line">        ChangeDbConnection(command, salveServer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 切换数据库连接</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"></summary></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><param name="command"></span><span class="doctag"></param></span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag"><param name="dbServer"></span><span class="doctag"></param></span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeDbConnection</span>(<span class="params">DbCommand command, DbServer dbServer</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> conn = command.Connection;</span><br><span class="line">        <span class="keyword">if</span> (conn.State == System.Data.ConnectionState.Open) conn.Close();</span><br><span class="line">        conn.ConnectionString = dbServer.ConnectionString;</span><br><span class="line">        conn.Open();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>接下来，和之前关于EF中的SQL拦截器类似，我们定义一个名为MasterSlaveDbInterceptor的拦截器：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MasterSlaveDbInterceptor</span> : <span class="title">DbCommandInterceptor</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">NonQueryExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<<span class="keyword">int</span>> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//Insert/Update(写操作)走主库</span></span><br><span class="line">        MasterSlaveManager.SwitchToMaster(command);</span><br><span class="line">        <span class="keyword">base</span>.NonQueryExecuting(command, interceptionContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ScalarExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<<span class="keyword">object</span>> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//Select(读操作)走从库</span></span><br><span class="line">        <span class="keyword">var</span> sqlText = command.CommandText;</span><br><span class="line">        <span class="keyword">if</span> (!sqlText.ToUpper().StartsWith(<span class="string">"INSERT"</span>) || !sqlText.ToUpper().StartsWith(<span class="string">"UPDATE"</span>))</span><br><span class="line">            MasterSlaveManager.SwitchToSlave(command);</span><br><span class="line">        <span class="keyword">base</span>.ScalarExecuting(command, interceptionContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ReaderExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//Select(读操作)走从库</span></span><br><span class="line">        <span class="keyword">var</span> sqlText = command.CommandText;</span><br><span class="line">        <span class="keyword">if</span> (!sqlText.ToUpper().StartsWith(<span class="string">"INSERT"</span>) || !sqlText.ToUpper().StartsWith(<span class="string">"UPDATE"</span>))</span><br><span class="line">            MasterSlaveManager.SwitchToSlave(command);</span><br><span class="line">        <span class="keyword">base</span>.ReaderExecuting(command, interceptionContext);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>至此，我们就实现了基于EF的数据库主从复制、读写分离。其实，更严谨的说法是，主从复制是在数据层面上完成的，而读写分离则是在代码层面上完成。当然，实际应用中需要考虑事务、数据库连接等因素，这里我们仅仅提供一种思路。这里我们的配置文件中，对主、从数据库进行了简单配置，即一主一从。在实际应用中，可能我们会遇到一注多从的情况，在这个基础上，我们又可以延申出新的话题，譬如在存在多个从库的情况下，通过心跳检测来检查从库服务器的健康状态，以及如何为不同的从库服务器设置权重，实现多个从库服务器的负载均衡等等。我们在微服务中提出的<strong>“健康检查”</strong>和<strong>“负载均衡”</strong>等概念，其实都可以映射到这里来，我想这是真正值得我们去深入研究的地方。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  并没有，いじょう</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
      <category term="读写分离" scheme="https://qinyuanpei.github.io/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="主从复制" scheme="https://qinyuanpei.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>戏里戏外的一出好戏</title>
    <link href="https://qinyuanpei.github.io/posts/1127467740/"/>
    <id>https://qinyuanpei.github.io/posts/1127467740/</id>
    <published>2018-10-11T09:02:05.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  上周国庆节放假，在家里看了黄渤的导演处女座《一出好戏》，虽然网上对它的评价还不错，可当我真正看完了这部电影，我反而觉得它更适合一个人的时候去看，因为在“演而优则导”的大趋势下，越来越多的人都在尝试“触电”，前有角逐奥斯卡的《逐梦演艺圈》，后有倒卖情怀的《爱情公寓》大电影，在这样一个充斥着“浮躁”的娱乐时代，有这样一类充满哲学意味的电影，可以说这是中国电影里的“净土”。不知道是不是因为年龄大了的缘故，对打打杀杀的动作戏显得视觉疲劳，有时候更愿意看点安静平淡的东西，这部电影所吸引我的，是某个镜头里无比空旷而迷离的故事和人们。</p><p>  “一出好戏”这四个字一出，陡然间有种开了上帝视角的感觉。其实，我们总以为在看戏里的别人，我们又何尝不是这戏里的人？就像人们觉得大街上耍猴有意思，人们看着被驯化的猴子，遵从人们的指令做出各种动作，人们瞬间有了种睥睨众生的感觉，可明明人类就是由猿猴进化而来，想到这一点，你忽然觉得人类世界的奇妙之处，即人类以自身有限的认知，所勾勒和描绘出的这个世界，其实永远都是冰山一角，在某种情况下，这种体系的崩塌，我让我们不得不重新审视自我的合理性，所谓“你站在桥上看风景，看风景的人在楼上看你 。明月装饰了你的窗子，你装饰了别人的梦”。</p><p>  整个故事架设在一个现代文明被摧毁的世界里，因为天外陨石落入海洋引发巨大海啸，男主马进及公司参与团建的众人，被困在一个与世隔绝的孤单上面。故事从男主颇具“屌丝”气质的自嘲开始，男主名叫马进，是一个在公司里基本没有存在感的人，连想给心仪的女生买饮料都要拐弯抹角，渴望通过买彩票实现一夜暴富的理想。这的确是一个普通社会阶层的真实写照，如男主所言，即便陨石真的落到地球上，像男主这样一穷二白的人，真的是穷到无所畏惧，可转眼间发现自己中了6000万彩票，同时流落到一个荒无人烟的孤单，如此喜剧性的一幕，无非是在质问我们，如果整个世界都遭遇崩塌，我们所在乎的这些，又到底该算作什么呢？</p><p>  我们不妨看看众人的反应，面对这样一个突如其来的灾难，首先被诘难的是史教授，它代表的是某种社会权威。接下来，被诘难的是张总，它代表是组织权威。这其实可以理解为一个群体引发的信任危机，史教授作为这个集体中的高端人才，他必须在抚慰群众人情绪和顾及自身尊严这两点上找到一个平衡，所以，他的做法是向大家“部分地”承认错误。而张总从一开始的认为“有钱可以搞到船”，到最后在岛上绝望地散尽“千金”，这同样是因为群体性的信任危机，所以，第一个点是，群体性的“信任危机”往往代表着某种体系崩溃的开始。马进身上的矛盾恰恰就在于此，他带着一个可能已经崩塌的世界里的产物——彩票，来到了一个全新的世界里，而在这个世界里，彩票是undefined，彩票映射的是作为一般等价物的货币，同样，货币在这个世界里是undefined。</p><p>  所以，电影所描绘的，其实更像是人类从无到有的演化过程。在众人缺乏食物和淡水的情况下，因为服过兵役而具备野外生存能力的小王，第一次成为了这个群体中的领袖。这象征的是人类历史上，以“体力”作为主要角逐指标的蛮荒时代。这里想吐槽下编剧的恶趣味，王根基这个名字实在是一言难尽。小王的策略是“想吃就自己干”，这其实是人类早期以采集狩猎为主的生活场景的反映，在这个阶段，对体力的重视超过对智力的重视，所以，史教授作为知识分子的身份第一次遭遇解离。人们普遍尊重劳动的价值，所以，两位没有参与劳动的“老总”，作为职场上司的身份遭遇第一次解离。同样，集体中身材最好的女性Lucy，被老潘一把推给“王”，这是早期推崇“体力”的体系中，对性资源的一种绝对占有。</p><p>  那么，在推崇“体力”的体系中，满足了人们的口腹之欲后，人们很快厌倦了这种满足感。以张总为代表的“智力”派，开始向着推崇“智力”的文明时代演变。在这个过程中，主要有两点，第一，是通过“期权”和“蓝图”发展出第一批员工。第二，是以扑克牌的形式定义了货币体系。这两点是整个社会转变的重要历程，第一点张总可以和“王”分庭抗礼的基础，而第二点则使得人们告别了“以物易物”的时代。张总利用马进想要离开孤单的心理，拉拢了岛上半数左右的人，可实际上他从未想过要带大家离开，这像不像现代职场里给期权的画饼方式？第二点，货币的出现让整个岛上的物品出现了流通。电影里有个人问，一张扑克牌能换多少鱼，张总回答说，这是有它的价值来决定的，这可以理解为经济学中的一个理论，即价格是由供需关系来决定的，故事到这里，我们已然看到了人类经济社会的雏形。</p><p>  如果说在“体力”时代，人们角逐方式就是争斗，小到人与人之间的决斗，大到部落与部落间的战争，那么，到了“智力”时代，人们开始追求更高阶的竞争。或许竞争是万物的天性，所谓“物竞天择，适者生存”，从小就被教育这套弱肉强食的丛林法则，更是在宫斗、商斗等一众“争斗”里不亦乐乎，当真是“与天奋斗，其乐无穷；与地奋斗，其乐无穷；与人奋斗，其乐无穷”啊……那么，当岛上两拨人为了食物而大打出手的时候，到底是生存更重要还是道德更重要？为什么进化到“智力”时代的人们，依然要面对像强盗一样的“体力”时代的人们？人类历史上有多少自诩正义的行为，其实带来的都是流血和牺牲？所谓“鹬蚌相争，渔翁得利”，最终是马进在这场争斗中获利。</p><p>  回头来看马进的行为，其实是群体中对优质资源的逐步占有的过程。如马进所言，只要是岛上生产不出的东西，都是宝贝。这里有两层意思，第一，物以稀为贵。第二，社会中的原始资源是有限的，只有不断创造新资源，整个社会的资源才能得以流通。虽然在电影中马小兴修坏了小王的水陆两用车，但其实电影想说的是，马小兴是所有人里唯一一个懂得现代科技的人，所以，马小兴的黑化，其实是马进人性中的阴暗面而已，当你真的拥有了摆布他人的能力，你是否又能守住道德的底线。</p><p>  马进成为取代“王”和张总，成为新的领袖，从故事上来说，多少有点宗教的意味。首先，在光影的掩映下以高姿态俯视众人，这是神化的过程，马进从一个不被人待见的无名之辈，瞬间转变为充满神性的人，神到了什么地步呢？甚至连女神珊珊都开始主动向他求爱。众人穿着白色竖纹衣服的那一幕真的很美好，就连Lucy跳绳的镜头我都看了好几遍😉。有没有觉得马进一手持书的样子像极了耶稣，如果说耶稣通过圣经来向世人传道，那么马进对着黑暗中众人的一番演讲，是否具有类似的教化的作用，马进再一次“刷新”了活着的定义，引导人们去重见光明、寻找新大陆和重建家园，至此，我们仿佛过渡到了追求精神文明的阶段。</p><p>  如果说，故事永远按照现在的方向去发展，那么或许在某个时刻人们就会回到“新大陆”，重新经历一次体系的重建。可生活从来都不是童话，导演用马小兴的黑化，完美地打破了这种想当然。或许有人会说，这是人类演化的必然，因为集体主义消亡以后，必然会导致精致的利己主义的产生，可即便如此，人们依然怀念着那个“罗曼蒂克”的时代，不是因为人们想要这样对别人，仅仅是希望别人这样对待自己而已。在张总主导的这个阶段，马进曾因为张总不愿意带大家离开，而被张总手下一通暴打，可其实他同样迷失在这份“岁月静好”中，所以，他不愿意让大家相信真的有大船经过，而这种内心的纠结，则完全交由马小兴来完成，主要事件有两个，其一是勒索张总资产，其二是小王“被得精神病”。电影快结束的时候，马进一直在重复“真的”还是“假的”，当一个人认识到这个社会的复杂性，当一个人在真真假假中来回穿梭的时候，或许他就会和马进一样，真的就分不出“真假”，可让马进走上神坛的电灯，和让小王变成“精神病”的电，难道不是一样的吗？</p><p>  在圣经故事里，耶稣最后被他的门徒犹大背叛，最终被人们钉上十字架，这是不是和马进被马小兴背叛特别相似？最后，岛上只有马进和珊珊的那一幕，我个人更倾向于理解为，这是马进内心的真实写照，他愿意和珊珊一起在这个岛上生活，可他并不愿意让其他人永远困在这个岛上，所以，这是他心中的一种美好的想象，真实的结局是大家一起乘船离开了荒岛，可据说船上放烟花，据说是泰坦尼克号事件以后的一种约定成俗，意思是一种求救信号，所以，这艘大船并不存在？结尾，众人一起到医院看马小兴，马小兴暂时失忆，大概导演是不想他想起那些“阴暗”的记忆，可如果这是暂时失忆，就是说终究会再想起来的，那么，结合马小兴的经历，或许马小兴内心深处就是这样的？众人惊愕地停在一圈儿精神病人面前，大概每个人面对荒诞的时候，都不能确定自己这算不算荒诞吧，可谁叫这就是个反乌托邦的荒诞故事呢？你说，这故事在那只蜥蜴的眼睛里又会是什么样子呢？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="https://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="https://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="一出好戏" scheme="https://qinyuanpei.github.io/tags/%E4%B8%80%E5%87%BA%E5%A5%BD%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode作为SourceTree的Diff和Merge工具</title>
    <link href="https://qinyuanpei.github.io/posts/3222622531/"/>
    <id>https://qinyuanpei.github.io/posts/3222622531/</id>
    <published>2018-09-30T08:43:44.000Z</published>
    <updated>2019-05-10T10:39:36.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  使用SourceTree有一段时间啦，从界面舒适度和易用性两个方面来看，的确要比小乌龟更好一点，日常配合命令行来使用，基本能覆盖到各种使用场景，譬如分支、版本、变基、合并等等。我本人在工作中接触到的Git工作流，大体上可以分为两类，从最早是官方所推崇的5个分支的Git Workflow，到如今在Github上更为流行的PR(Pull Request)。这两种方式，实际使用中各有优劣吧，而且这个话题似乎更适合专门写一篇文章来说。</p><p> 我真正想说的是，我需要一个优雅的Diff和Merge工具。虽然，对一个使用命令行的人来说，使用git diff来展示差异对比已经完全足够啦，可在某些需要解决冲突的场合，命令行就显得有点力不从心。我个人一直不习惯小乌龟的合并工具，因为使用起来总觉得相当别扭。直到我发现，VSCode可以在打开冲突文件的时候，自动提示解决冲突的选项，我觉得我开始喜欢上这个工具啦。所以，平时我解决冲突的做法是，在命令行里找到冲突的文件，然后逐一用VSCode打开来解决冲突。</p><p> 现在，使用SourceTree的时候，周围同事大部分都习惯GUI操作，所以，就想能不能把SourceTree和VSCode结合着来用，因为我发现SourceTree可以支持外部的Diff和Merge工具。其实，小乌龟一样是支持的，关键是配置太难用啦！SourceTree支持的Merge工具里有鼎鼎大名的P4Merge，不过我发现一来官网完全打不开(需要翻墙)，二来界面相当复古我不喜欢，而SourceTree默认的Merge工具其实就是小乌龟里的，所以，请允许我如此任性的折腾吧！</p><p> 首先，确保你安装了VSCode，这显然是一句废话，可对于博主来说，这是唯一可以替代Sublime Text的代码编辑器，想想可以写Markdown、写Python、写JS、写.NET Core，简直不能更美好了好嘛？然后，我们在SourceTree里做如下配置，这里我们直接让VSCode作为我们的Diff和Merge工具，具体参数如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/4c36074fly1fymku875hdj20ix0got97.jpg" alt="SourceTree配置图示" title>                </div>                <div class="image-caption">SourceTree配置图示</div>            </figure><p> 好了，现在我们就可以在SourceTree里愉快地使用VSCode啦，感受一下这如德芙一般的纵想丝毫，从现在开始，彻底忘掉小乌龟那丑陋的合并工具吧！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img-blog.csdn.net/20180930171206711" alt="VSCode解决冲突" title>                </div>                <div class="image-caption">VSCode解决冲突</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/2018093017130972" alt="VSCode差异比较" title>                </div>                <div class="image-caption">VSCode差异比较</div>            </figure><p> 既然，作为Git可视化工具的SourceTree可以使用VSCode作为Diff和Merge的工具，那么，我们干脆一鼓作气，将VSCode作为Git默认的Diff和Merge的工具吧！熟悉Git命令行的朋友一定遇到过这样的场景，有时候，我们执行完git merge以后，命令行会采用Vim的方式来进行交互，这是因为Git默认的编辑器就是Vim，为什么是Vim呢？因为Git和Linux一样，都出自Linus大神之手啊！所以，这句话的意思是，我们可以给Git配置外部工具，譬如小乌龟、P4Merge等等，这里直接给出相关命令：<br></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Merge时不创建备份文件</span><br><span class="line">git config --global al mergetool.keepBackup fap false</span><br><span class="line"></span><br><span class="line">//配置Diff工具</span><br><span class="line">git config --global al diff.tool cod code</span><br><span class="line">git config --global al difftool.prompt mpt false</span><br><span class="line">git config --global al difftool.code.cmd '"C '"C:\Program Files\Microsoft VS Code\de\Code.exe" "-" "--wait --diff" "$LOCAL" "$REMOTE"'</span><br><span class="line"></span><br><span class="line">//配置Merge工具</span><br><span class="line">git config --global al merge.tool cod code</span><br><span class="line">git config --global al mergetool.prompt mpt false</span><br><span class="line">git config --global al mergetool.code.cmd '"C '"C:\Program Files\Microsoft VS Code\de\Code.exe" "-" "--wait" "$MERGED"'</span><br><span class="line">git config --global al mergetool.code.trustexitcodecode true</span><br></pre></td></tr></tbody></table></figure><p></p><p> OK，配置完Git以后，遇到用到需要Diff的场景，我们只需要执行git difftool；而需要用到Merge的场景，我们只需要执行git mergetool。直接合理搭配工具，Git一样可以变得非常可爱，而不是一堆枯燥乏味的命令行，好啦，Enjoy it，难得写一篇不那么技术向的博客，以后记得早点睡觉~zZ，晚安！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="https://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://qinyuanpei.github.io/tags/Git/"/>
    
      <category term="VSCode" scheme="https://qinyuanpei.github.io/tags/VSCode/"/>
    
      <category term="SourceTree" scheme="https://qinyuanpei.github.io/tags/SourceTree/"/>
    
  </entry>
  
  <entry>
    <title>记通过EF生成不同数据库SQL脚本的一次尝试</title>
    <link href="https://qinyuanpei.github.io/posts/795474045/"/>
    <id>https://qinyuanpei.github.io/posts/795474045/</id>
    <published>2018-09-17T09:42:23.000Z</published>
    <updated>2019-05-10T10:39:36.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  接触新项目有段时间了，如果让我用一句话来形容此刻的感受，大概就是<strong>“痛并快乐着”</strong>。痛苦之一是面对TFS，因为它的分支管理实在是一言难尽，无时无刻不在体验着人肉合代码的“趣味”。而痛苦之二是同时维护三套数据库的脚本，这让我想到一个梗，在讲到设计模式的时候，一个常常被提到的场景是，怎么样从设计上支持不同数据库的切换。我想，这个问题是非常容易回答的，真正的问题是我们真的需要切换数据库吗？原谅我的年少无知，我们的产品因为要同时支持公有云和私有化部署，所以在数据库的选择上，覆盖到了主流MySQL、Oracle和SQL Server，这直接导致我们要维护三套数据库的脚本，你说这样子能不痛苦吗？而快乐的地方在于，终于有机会在一个有一定用户体量的产品上参与研发，以及从下周开始我们将从TFS切换到Git。好了，今天这篇文章的主题是，<strong>通过EF来生成不同数据库的SQL脚本</strong>，这是痛苦中的一次尝试，所谓<strong>“痛并快乐着”</strong>。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>  我们知道数据库和面向对象这两者间存在着天然阻抗，这是因为两者在事物的认知上存在差异，数据库关注的是二维表、是集合间的关系，而面向对象关注的是封装、是细节的隐藏，所以，不管到什么时候，这两者都只能以某种尴尬的方式共存，SQL执行效率高，这是以牺牲可读性为代价的； ORM迎合了面向对象，这是以牺牲性能为代价的，所以，即使到了今天，关于SQL和ORM的争论从来没有停止过，甚至写SQL的人不知不觉间“造”出了ORM，而使用ORM的人有时需要SQL。所以，面对这样一个需要同时维护三套数据库脚本的工作，我个人倾向于用工具去生成，或许是出于程序员对“懒”这种美德的极致追求，或许是出于我对SQL这种“方言”天生的排斥，总而言之，我不是很喜欢手写SQL除非特别必要，因为它和正则一样，只有写得人懂它真正的含义。</p><p>  那么，说到这里，我们就知道了一件事情，ORM可以帮助我们生成SQL，所以，我们为什么不让它帮我们生成不同数据库的SQL脚本呢？虽然ORM的性能总是为人所诟病，因为它严格遵循某种规则，所以注定做不到像人类一样“灵活”。我们始终认为不“灵活”的就是“笨拙”的，可即便如此ORM生成的SQL依然比人类写得要好看。故而，我们的思路是，<strong>在ORM生成SQL语句的时候将其记录下来，然后按照一定规则生成不同数据库的脚本</strong>。毕竟SQL语言更接近“方言”，每一种数据库的SQL脚本都存在着细微的差别。所以，后来人们不得不发明T-SQL，可任何东西归根结底不都是权力和利益带来的附属品吗？人类为了互相竞争而形成差异化，可当一切差异都不甚明显时，最终又不得不花费精力来解决这些差异。可一个只有垄断存在的世界，除了让人想起1984里的Big Brother以外，还能想起什么呢？</p><h1 id="尝试过程"><a href="#尝试过程" class="headerlink" title="尝试过程"></a>尝试过程</h1><p>  好了，顺着这个思路，我们就会想到在ORM中添加拦截器或者是日志的方式，来获得由ORM生成的SQL语句，这里我们以Entity Framework(以下简称EF)为例，这是.NET中最常见的ORM，因为目前官方的Web开发框架有ASP.NET和ASP.NET Core两个版本，所以这里我们分别以ASP.NET和ASP.NET Core为例来说明具体的实现过程，相应地，我们分别使用了EF6和EF Core 作为各自的ORM。 </p><h2 id="EF6"><a href="#EF6" class="headerlink" title="EF6"></a>EF6</h2><p>  对于EF6，我们可以通过继承<strong>DbCommandInterecptor</strong>类来编写一个拦截器。而在拦截器中重写相应的方法，就可以对数据库中的常见操作(CURD)进行拦截。所以，根据这个思路，我们会联想到，通常数据库迁移都是针对“写”这个操作，因此，我们的想法是记录INSERT和UPDATE两种SQL语句。这里我们通过下面的示例来验证这个想法，需要说明的是，本文中所有数据库相关的示例，均采用Code First的方式来创建。<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SQLGenInterceptor</span> : <span class="title">DbCommandInterceptor</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">NonQueryExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<<span class="keyword">int</span>> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> sqlText = FormatSQL(command);</span><br><span class="line">        Log.Info(sqlText);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ReaderExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> sqlText = FormatSQL(command);</span><br><span class="line">        Log.Info(sqlText);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ScalarExecuting</span>(<span class="params">DbCommand command, DbCommandInterceptionContext<<span class="keyword">object</span>> interceptionContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> sqlText = FormatSQL(command);</span><br><span class="line">        Log.Info(sqlText);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">FormatSQL</span>(<span class="params">DbCommand command</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> sqlText = command.CommandText;</span><br><span class="line">        <span class="keyword">foreach</span> (DbParameter sqlParam <span class="keyword">in</span> command.Parameters)</span><br><span class="line">        {</span><br><span class="line">            sqlText = sqlText.Replace(sqlParam.ParameterName,            sqlParam.Value.ToString());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlText;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  在这个示例中，我们使用NLog来记录由EF生成的SQL语句，可以注意到它比我们想象中的要稍微复杂些，所以，人们说ORM性能差并不是没有道理。可当你见过那些由人手写出的天书一般的SQL语句后，也许两者在可读性上来说不过是五十步笑百步。实际上EF生成的SQL是一种叫做T-SQL的东西，你可以把它理解为一种标准的SQL语言。譬如在PowerBuilder这个数据库建模软件中，我们可以通过T-SQL转换出主流数据库的SQL语句。博主在工作中需要维护三套SQL脚本，而这些脚本间细小的语法差异，就变成了这个过程中最难忘的记忆，这里我们不考虑去做语法转换的事情，因为实际上通过传入不同的连接字符串，我们就能得到不同数据库的SQL脚本，所以接下来的工作就交给各位了(逃……</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入SQLGen拦截器</span></span><br><span class="line">DbInterception.Add(<span class="keyword">new</span> SQLGenInterceptor());</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> DataContext())</span><br><span class="line">{</span><br><span class="line">    context.Users.Add(<span class="keyword">new</span> User()</span><br><span class="line">    {</span><br><span class="line">        UserName = <span class="string">"PayneQin"</span>,</span><br><span class="line">        UserRole = <span class="string">"Administrator"</span></span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    context.SaveChanges();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  现在，我们需要将这个拦截器注册到EF中，注册过程非常简单，一旦拦截器注册完成，当我们在EF中执行相应操作的时候，就可以在日志中看到相对应的SQ语句了，这样我们就达到了用EF生成SQL语句的目的，虽然说这样可能还没手写来快，可它至少让你知道了，这个世界上有一种不需要手写SQL的可能性啊，你说对吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05glt2tij20j306x74e.jpg" alt="EF生成SQL语句比想象中更为复杂" title>                </div>                <div class="image-caption">EF生成SQL语句比想象中更为复杂</div>            </figure><h2 id="EF-Core"><a href="#EF-Core" class="headerlink" title="EF Core"></a>EF Core</h2><p>  对于EF Core来说，它并没有提供像EF6那样的拦截器，虽然官方曾经说过后续会做这方面的工作[摊手]……不过办法终究是人想出来的，对于EF Core我们可以通过注入日志的方式来实现。我们知道，微软在.NET Core中大力地发展了依赖注入、中间件等一系列特性，所以，这对于我们这种喜欢搞事情的人来说，简直太方便了有木有啊！.NET Core中日志注入主要集中在ILogger、ILoggerFactory和ILoggerProvider三个接口，简单来说，ILoggerFactory是日志工厂，负责返回具体的Logger；而ILoggerProvider，则决定在什么情况下应该提供什么样的Logger。最常见的两种LoggerProvider是Console和Debug，它们分别通过AddConsole()和AddDebug()来注入。具体到这里，我们通过下面的方式实现：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SQLGenLogger</span> : <span class="title">ILogger</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> categoryName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLGenLogger</span>(<span class="params"><span class="keyword">string</span> categoryName</span>)</span> => <span class="keyword">this</span>.categoryName = categoryName;</span><br><span class="line">    <span class="keyword">public</span> IDisposable BeginScope<TState>(TState state) => <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsEnabled</span>(<span class="params">LogLevel logLevel</span>)</span> => <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, <span class="keyword">string</span>> formatter)</span><br><span class="line">    {</span><br><span class="line">        Log.Info(state)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  首先定义SQLGenLogger，顾名思义，它是用来记录生成的SQL语句的，同样，我们选择了NLog。这里有一点要说明，平时我们在控制器中使用ILogger的时候，通常会在控制器的构造函数中注入ILogger<foocontroller>，一旦我们使用泛型的ILogger接口，Log()方法中的参数state实际上就是当前类型，这里和SQL语句相关的类型DbCommandData，实际上是博主试出来的，因为如果不限定ILogger<t>中的参数T，我们将得到所有的执行日志，显然，这不是我们想要的结果。</t></foocontroller></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SQLGenLoggerProvider</span> : <span class="title">ILoggerProvider</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILogger <span class="title">CreateLogger</span>(<span class="params"><span class="keyword">string</span> categoryName</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">if</span>(categoryName  == <span class="string">"Microsoft.EntityFrameworkCore.Database.Command"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SQLGenLogger(categoryName);</span><br><span class="line">        <span class="keyword">return</span> NullLogger.Instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  接下来来看，ILoggerProvider接口的实现。我们说过，ILoggerProvider接口决定在什么情况下应该提供什么样的Logger，我们注意到它提供了一个CreateLogger()的方法，它会根据categoryName来返回不同的Logger，而参数categoryName实际上等价与nameof(FooController)，所以，到这里我们就会明白，为什么这里要判断categoryName了，它实际上起一个过滤的作用，因为我们只需要SQL相关的日志，它和SQLGenLogger中的state相对应，我们已经说过，这是博主试出来的。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataContext</span> : <span class="title">DbContext</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DbSet<User> Users { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">var</span> loggerFactory = <span class="keyword">new</span> LoggerFactory();</span><br><span class="line">        loggerFactory.AddProvider(<span class="keyword">new</span> SQLGenLoggerProvider());</span><br><span class="line">        <span class="comment">//在这里注入日志工厂</span></span><br><span class="line">        optionsBuilder.UseLoggerFactory(loggerFactory)</span><br><span class="line">            .EnableSensitiveDataLogging()</span><br><span class="line">            .UseSqlServer(<span class="string">@"Data Source=(LocalDb)\MSSQLLocalDB;Initial Catalog=SQLGen.DataContext;Integrated Security=True;MultipleActiveResultSets=True;App=EntityFramework"</span>); </span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">  modelBuilder.ApplyConfiguration(<span class="keyword">new</span> UserTypeMap());</span><br><span class="line">  modelBuilder.Entity<User>().ToTable(<span class="string">"Users"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  好啦，接下来就非常简单啦，我们在DbContext里对EF的Logger进行配置，把我们定义的SQLGenLoggerProvider注入到EF里，可以注意到，它可以如我们期望得那样，输出由EF生成的SQL脚本，这实在是有趣，Ok，打完收工！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz02250ixxj20u904w74c.jpg" alt="通过注入日志获取EF生成的SQL" title>                </div>                <div class="image-caption">通过注入日志获取EF生成的SQL</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  我一直相信，懒惰是工程师的一种美德，因为为了让自己有机会懒惰，你就必须要先让自己勤奋起来。我一直怕自己在舒适区里温水煮青蛙，明明一直在重复做一件事情，还要安慰自己说：“做好这一件事情一样是成功“，有时候，一味地重复自己并不见得会有太多收获，所以，就像这篇文章一样，我本来像偷懒少写一点SQL，结果意外地发现了给数据库记录日志的方法。当有了意外收获以后，曾经的初衷到底是什么可能就没那么重要了，如“雨血”中左殇所说，当你赢了的时候，你说曾经有十成把握亦不为过。</p><p>  这篇文章主要介绍如何利用EF来生成不同数据库的SQL脚本，对EF6来说，需要继承DbCommandInterecptor类编写拦截器；对于EF Core来说，需要注入ILogger来记录日志。本文的延伸之一是记录SQL执行日志，这一点在本文已经有所体现。本文更深层次的延伸是，在这个基础上实现数据库的主从复制、读写分离，这一点我会在下一篇博客中讲解，欢迎大家继续关注我的博客，好啦，以上就是这篇文章的全部内容啦，晚安！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
      <category term="Logger" scheme="https://qinyuanpei.github.io/tags/Logger/"/>
    
  </entry>
  
  <entry>
    <title>漫谈前端进化史之从Form表单到文件上传</title>
    <link href="https://qinyuanpei.github.io/posts/2463121881/"/>
    <id>https://qinyuanpei.github.io/posts/2463121881/</id>
    <published>2018-09-05T12:57:36.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  Hi，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天这篇博客，我们来说说文件上传相关的内容。看到这里，大家一定觉得博主在技术上越来越没追求了吧，文件上传这种再简单不过的东西，真的值得博主你专门写篇博客吗？在介绍声明式RESTful客户端WebApiClient的这篇<a href>文章</a>中，博主曾经提到，HTTP协议中对文件上传的支持，主要是通过multipart/form-data来实现。因为这种方式是将文件视为一种特殊的键值对，所以对这种方式我本人不太喜欢。可作为标准的意义就是要忽略个人的情感因素，所以，在今天这篇文章中，博主更多的是想从HTTP协议(<strong>RFC2388</strong>)的角度来看待这个问题，即为什么它选择了multipart/form-data来实现上传，以及伴随着前端技术的发展它经历了哪些变化。</p><h1 id="从Form表单说起"><a href="#从Form表单说起" class="headerlink" title="从Form表单说起"></a>从Form表单说起</h1><p>  圣经上开篇就点明主旨，“起初神创造天地。地是空虚混沌。渊面黑暗”。一切的一切，都要从神创造天地开始，神说，要有光，这世上便有了光。那么，对于HTTP协议我们要从哪里开始说起呢。HTTP的全称是超文本传输协议，所以，它设计的初衷是传输超文本类型的数据。什么是超文本类型的数据呢？从现代网页的组成，我们就可以知道，它不单单是指文本类信息，同时指图片、音频、视频等等一切可能的信息形式。可神奇的地方就在于，HTTP协议是基于文本的协议，这意味着我们在网页中的信息交换，是借助某种文本类型的通信协议。顺着这个思路，最早我们在网页中交换信息的方式是什么呢？我认为是Form表单。想想看，我们在Form表单中输入信息，然后通过一个按钮将数据提交到服务器，服务器会对我们的请求做出响应。事实上，直到今天，我们的前端依然在采用这一机制。所不同的是，我们今天用各种组件替代了Form表单。</p><p>  如果我们讲各种语言的”打印”理解为Hello World，那么对前端而言最浅显的Hello World是什么呢？我个人以为是登录，想象一下，这是任何一个Web应用里都有的功能，我们输入用户名和密码以后，点击“登录”按钮就可以登录到系统。虽然，此时此刻的你我，都知道这是一个简单的POST请求，甚至对于用户名和密码这两个字段，我们有多种方法可以将其传递到服务器上。那么，各位是否知道，我们通过Form表单来登录时，这个过程中到底发生了什么呢？既然提到了登录，那么我们这里通过下面的例子来分析。</p><p>  如你所见，这是一个相当“简陋”的Web页面。对一名后端开发人员而言，精致的Web页面就是一段被套在华丽外壳里的代码(不知道这样会不会被前端网红们打死)。所以，排除了样式相关的CSS，可以让我们更加专注于核心原理。同样地，我们编写了一个简单的Web API，来处理前端发送来的HTTP请求，这不是本文的重点，我们假设它存在且可以工作就好。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy867pz8j20ig07laa5.jpg" alt="HTML结构/界面" title>                </div>                <div class="image-caption">HTML结构/界面</div>            </figure><p>  这里已经说过，比起炫酷的Web页面和后端接口，我们这里更关心的是，登录时到底发生了什么。所以，大家都猜对了，通过Chrome自带的开发人员工具，我们可以捕捉到点击“登录”按钮时发出的HTTP请求，我们一起来看看它的报文内容是什么吧，相信大家都会有一种恍然大悟的感觉，让我们拭目以待吧！<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy5kad23j20if08k3z9.jpg" alt="encrypt为x-www-form-urlencode时的请求报文" title>                </div>                <div class="image-caption">encrypt为x-www-form-urlencode时的请求报文</div>            </figure><p></p><p>  通过这个报文内容，我们可以发现，“登录”实际上是一个POST请求，这是因为我们在HTML结构中声明了，Form表单用什么样的方式去提交数据。而实际上呢，Form表单默认的行为是GET。我们同样会注意到报文中的Content-Type为application/x-www-form-urlencode，它的特点是采用类似key1=value1&key2=value2……的形式来提交数据，并且每一个value都会被编码。这样，我们就不得不提到Form表单的encrypt属性，它有三种基本取值：text/plain、application/x-www-form-urlencode和multipart/form-data。其中，text/plain这种不必再说，因为它传递的是纯文本数据。而对于multipart/form-data来说，它的特点是采用一系列的boundary来分割不同的值，如果我们将示例中Form表单的encrypt属性设为multipart/form-data，就会得到下面的报文内容，可以注意到，它和我们预期是一致的。<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzg5fsdj20rv0dv75u.jpg" alt="encrypt为multipart/form-data时的请求报文" title>                </div>                <div class="image-caption">encrypt为multipart/form-data时的请求报文</div>            </figure><p></p><p>  或许大家会说，现在我们用AJAX来请求RESTful风格的API时，不都是用JSON作为数据交换的格式吗？对于这一点，或许我们可以理解为，Form表单是封装了有限的3种Content-Type的XHR对象，所以，Form表单足以让我们一窥AJAX最初的样子。虽然，我们今天已经不再主张使用jQuery，但是熟悉jQuery的朋友一定知道这一点，即jQuery中默认的Content-Type示例上是application/x-www-form-urlencoded。所以，即使我们今天有了全新的Fetch API，可它依然脱离不了HTTP协议的范畴。可或许正因为如此，HTTP中的文件上传多少像是某种妥协的产物。</p><h1 id="神奇的Input控件"><a href="#神奇的Input控件" class="headerlink" title="神奇的Input控件"></a>神奇的Input控件</h1><p>  OK，在本文的第一节，我们使用的是最简单的Input控件，即它的type属性为“text”。事实上，Input控件是一个神奇的控件，因为不同的type会有不同的作用。例如，type为password对应密码域；type为checkbox对应复选；type为radio对应单选域；type为button对应按钮域等等……有很多朋友可能会问，你说的这个和这篇文章有什么关系吗？我想说的是，当然有关系而且关系密切，因为我们下面要提到的这种Input控件，和本文想要说明的HTTP上传，在本质上有着千丝万缕的联系。具体是什么样的联系呢？我们来一起看下面的这个例子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05o9mcsoj20h606uq2s.jpg" alt="HTTP_Upload_06" title>                </div>                <div class="image-caption">HTTP_Upload_06</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05ljreo8j20me08vt98.jpg" alt="HTTP_Upload_05" title>                </div>                <div class="image-caption">HTTP_Upload_05</div>            </figure><p>  通过这个例子，我们很容易发现的一点是，当我们采用type为file的Input控件上传一个文件时，它会采用multipart/form-data来传递数据，报文中使用了和第二个示例类似的结构，即第一部分负责描述文件信息，譬如文件的名称、扩展名类型等等；第二部分表示文件数据流，可以理解为二进制形式的内容。既然它采用multipart/form-data来传递数据，那么这是否意味着，我们可以在这个结构中携带更多的信息呢？譬如，有时候我们需要将文件和用户提交的信息关联起来，这个时候就需要将这些信息一切提交到服务器端，如果我们将其拆分为两个API来实现，那么就需要去花精力维护这个关联的id啦。答案自然是可以的，只要把文件视为一种特殊的键值对即可。</p><h1 id="HTTP与文件上传"><a href="#HTTP与文件上传" class="headerlink" title="HTTP与文件上传"></a>HTTP与文件上传</h1><p>  好了，说了这多么内容，是时候来说说HTTP与文件上传啦！现在大家都知道了，HTTP上传实际上是在multipart/form-data基础上扩展而来的。早期人们在制定HTTP协议的时候，并没有想到用它来作为文件上传的协议，因为事实上TPC/IP或者FTP都可以提供更好的上传支持。当我们回顾Form表单中关于HTTP的部分，我们就会发现，HTTP中具备上传文件可能性的方式只有两种，即multipart/form-data和x-www-form-urlencode。这里为什么不考虑text/plain呢？尽管从理论上来讲，它可以作为文件上传的一种方式，此时，它相当于把整个文件的内容全部放在请求体(body)中。从实用性角度来讲，text/pain在实际应用中并不多见，因为采用纯文本意味着客户端与服务端必须按照某种规则去解析报文。而从功能性角度来讲，把整个文件的内容全部放在请求体中，则会造成文件信息的不完整，因为此时文件名等信息是没有办法传输到服务器端的，所以，这样综合下来再看的话，HTTP协议本身留给我们的选择的空间并不大，我们能够选择的就只有multipart/form-data和x-www-form-urlencode这两种啦，下面着重来分析下这种数据加密方式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05f46qf1j20rv0dvjso.jpg" alt="HTTP_Upload_07" title>                </div>                <div class="image-caption">HTTP_Upload_07</div>            </figure><p>  对于Content-Type为multipart/form-data而言，首先，它会在请求头部的Content-Type字段中，声明当前的内容类型为multipart/form-data，并指定一个名为boundary的随机字符串，它的含义是说，从现在开始，请求中的每一个“字段”都会用这个名为boundary的随机字符串进行分割。而对于每一个“字段”而言，它可以拥有部分子头部字段，一个最为常见的头部字段是Content-Disposition，其取值为form-data。除此之外，每一个“字段”可以在<strong>Content-Disposition: form-data;</strong>后追加若干个字段，譬如name、filename以及用以指定文件类型的Content-Type(假如这个“字段”是一个文件的话)。HTTP协议中还规定这里可以支持扩展字段。我们通过type为file 的Input控件进行上传时，默认的name为multipartfile，当服务器端接受到类似的字段时，就会根据报文对文件进行拼接，所以，对于HTTP上传来说，它可以支持多个文件并发上传，但并不直接支持断点续传。注意这里我说的是，不直接支持断点续传，实际上它可以通过请求头部中的Range字段来实现，当然这已经超出了这篇文章的范畴。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz020zu3ooj20t90903zd.jpg" alt="HTTP_Upload_08" title>                </div>                <div class="image-caption">HTTP_Upload_08</div>            </figure><p>  对于Content-Type为x-www-form-urlencode而言，它会将请求中的每一个字段以key1=value1&key2=value2……的形式串联起来，并对每一个value进行编程，这种传值方式我们一般称为QueryString，而更为一般的场景是，我们在通过GET方式请求数据的时候，QueryString是唯一的传参方式，不同之处是GET请求的参数是附加在URL上，而POST请求的参数是附加在body里。如果我们用这种方式来上传文件会怎么样呢？答案是，当我们试图将一个文件以x-www-form-urlencode方式进行传输时，文件流会被彻底忽略，它实际传输的是对应文件的名称。所以，从这个角度来讲，它不能用于文件的上传。事实上，它是被设计用来传输非二进制数据的，那么可能有人要问啦，那我如果有JSON来传输文件可不可以呢？理论上应该没有问题，曾经我们在一个项目中用JSON描述图片，当然这是经过Base64编码以后的图片。回过头来看text/plain，我们把JSON字符串直接放到body里可不可以呢？当然没有问题，因为问题全部转移到服务器端。所以，官方建议用它来作为调试的一种选择。</p><p>  现在，我们可以来总结下Form表单和HTTP协议间的关系啦！首先，Form表单可以提交非二进制数据和二进制数据。非二进制数据，比如一般表单中提交的各种文本信息，用户名、密码这一类等等。二进制数据，主要指各种不同类型的文件等等。对于非二进制数据，可以通过x-www-form-urlencode或者multipart/form-data两种编码方式来提交。对于二进制数据，只能通过multipart/form-data这种方式来提交。所以，当我们需要混合提交二进制数据和非二进制数据的时候，我们就只有multipart/form-data这一种选择啦！更一般的结论是，只要我们的Form表单里有一个type为file的Input控件，对应POST请求的Content-Type就会变为multipart/form-data。我不喜欢这种方式的原因之一，就是构造它的HTTP报文非常难受。如果用HttpClient，痛苦会降低很多；而如果用HttpWebRequest，我会感到绝望。当然，你此时已明白了这个原理，相信Postman可以帮到你的忙。</p><h1 id="Form表单消失以后"><a href="#Form表单消失以后" class="headerlink" title="Form表单消失以后"></a>Form表单消失以后</h1><p>  熟悉前端演变历程的朋友，应该对我下面要说的历史表示怀念。在很久很久以前，我们的网页三剑客分别是Dreamwave、Fireworks和Flash。那个时候我们用Dreamwave制作的网页充斥着大量的Form表单，通过JS实现对数据的校验，就像这篇文章里描述的一样，我们做几个type为submit的按钮，就可以把数据提交到服务器端。按理说，这样子很没完美啊，我们可以提交用户输入的信息，可以上传用户选择的文件，何乐而不为呢？为什么大家要用Div + CSS淘汰Form表单呢？我认为主要有两点，传统的基于表格的布局无法满足现代Web程序的布局要求，RESTful风格Web API的出现让开发者希望前后端交互可控。换言之，开发者希望通过FormData这样的对象，精细地控制整个请求的细节，而不是交给一个由浏览器发出的POST请求。所以，我们看到了前端文件上传的新思路。</p><p>  首先，最常见的方式，是通过监听Input控件的onchange方法，通过files属性即可获得当前用户选择的文件。我们知道，在大多数情况下，前端是无法和本地文件系统进行交互的。因此通过这种方式获得文件路径，实际上是一个指向本地数据的blob，前端将文件相关的type和size组织到一个FormData对象的实际中，即可完成对文件的上传。其次，可以利用HTML5中的“拖拽”和“粘贴”，其核心依然是监听相关的事件，然后从中获取File对象或者blob对象的实例，一旦获得了这些实例，就可以将其添加到FormData中。到了这一步，接下来的就和第一种方法完全一样啦！最后，是类似百度出品的WebUploader这类HTML5和Flash混合的插件，主打兼容性，不过随着大家对IE8以下版本兼容问题的逐步放弃，这类产品的使用场景会越来越少，我们大概知道就可以啦！归根到底一句话，Form表单和FormData对象，其实是可以相互转化的，Form表单里每一个Input控件的name，其实就是FormData里的key啦，到了这一步，我想HTTP上传就没有什么好神秘了的吧！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  本文从Form表单说起，首先探讨了Form表单和HTTP之间的关系，即Form表单在提交数据的时候，背后的本质其实是一条HTTP请求，相对应地，Form表单默认的请求方式是GET，在第一个示例中，我们分别展示了使用x-www-form-urlencode和multipart/form-data时请求报文实际的内容。接下来，我们提到了HTML中的Input控件，它可以通过指定不同的type达到不同的效果，作为第一个示例的延伸，我们尝试通过Form表单上传文件并重点关注其报文的结构。接下来，我们从协议的角度分析了为什么要选用multipart/form-data来上传文件以及它的原理是什么。最后，我们从前端常见的文件上传方式入手，简要分析了Form表单和FormData对象间的内在联系，即Form表单和FormData对象，其实是可以相互转化的，Form表单里每一个Input控件的name，其实就是FormData里的key。好啦，又是一个难以入眠的夜晚，这篇博客先写到这里，大家晚安！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="HTTP" scheme="https://qinyuanpei.github.io/tags/HTTP/"/>
    
      <category term="Form" scheme="https://qinyuanpei.github.io/tags/Form/"/>
    
      <category term="RFC" scheme="https://qinyuanpei.github.io/tags/RFC/"/>
    
  </entry>
  
  <entry>
    <title>基于WebSocket和Redis实现Bilibili弹幕效果</title>
    <link href="https://qinyuanpei.github.io/posts/3269605707/"/>
    <id>https://qinyuanpei.github.io/posts/3269605707/</id>
    <published>2018-08-22T14:07:23.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  嗨，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。在上一篇博客中，我们使用了.NET Core和Vue搭建了一个基于WebSocket的聊天室。在今天这篇文章中，我们会继续深入这个话题。博主研究WebSocket的初衷是，我们的项目上有需要实时去推送数据来完成图表展示的业务，而博主本人对这个内容比较感兴趣，因为博主有对爬虫抓取的内容进行数据可视化(<strong>ECharts</strong>)的想法。可遗憾的是，这些数据量都不算太大，因为难以支持实时推送这个想法，当然更遗憾的是，我无法在项目中验证以上脑洞，所以，最终退而求其次，博主打算用Redis和WebSocket做一个弹幕的Demo，之所以用Redis，是因为博主懒到不想折腾RabbitMQ。的确，这世界上有很多事情都是没有道理的啊……</p><p>  其实，作为一个业余的数据分析爱好者，我是非常乐意看到炫酷的ECharts图表呈现在我的面前的，可当你无法从一个项目中收获到什么的时候，你唯一的选择就是项目以外的地方啦，所以，在今天这样一个精细化分工的时代，即使你没有机会独立地完成一个项目，我依然鼓励大家去了解项目的“上下文”，因为单单了解一个点并不足以了解事物的全貌。好了，下面我们来简单说明下这个Demo整体的设计思路，即我们通过Redis来“模拟”一个简单的消息队列，客户端发送的弹幕会被推送到消息队列中。当WebSocket完成握手以后，我们定时从消息队列中取出弹幕，并推送到所有客户端。当客户端接收到服务端推送的消息后，我们通过Canvas API完成对弹幕的绘制，这样就可以实现一个基本的弹幕系统啦！</p><h1 id="编写消息推送中间件"><a href="#编写消息推送中间件" class="headerlink" title="编写消息推送中间件"></a>编写消息推送中间件</h1><p>  首先，我们来实现服务端的消息推送，其基本原理是：在客户端和服务端完成“握手”后，我们循环地从消息队列中取出消息，并将消息群发至每一个客户端，这样就完成了消息的推送。同上一篇文章一样，我们继续基于“中间件”的形式，来编写消息推送相关的服务。这样，两个WebSocket服务可以独立运行而不受到相互的干扰，因为我们将采用两个不同的路由。在上一篇文章中，我们给“聊天”中间件WebSocketChat配置的路由为<strong>/ws</strong>ws。这里，我们将“消息推送”中间件WebSocketPush配置的路由为<strong>/push</strong>。这块儿我们做了简化，不再对所有WebSocket的连接状态进行维护，因为对一个弹幕系统而言，它不需要让别人了解某个用户的状态是否发生了变化。所以，这里我们给出关键的代码。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!IsWebSocket(context))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">    _socketList.Add(webSocket);</span><br><span class="line">    <span class="keyword">while</span> (webSocket.State == WebSocketState.Open)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> message = _messageQueue.Pull(<span class="string">"barrage"</span>,TimeSpan.FromMilliseconds(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> socket <span class="keyword">in</span> _socketList)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">await</span> SendMessage(socket,message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">"Close"</span>, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样地，我们需要在Startup类中添加WebSocketPush中间件。按照ASP.NET Core中的惯例，我们为IAppBuilder接口增加一个名为UseWebSocketPush的扩展方法。这样，可以让我们直接使用该方法完成中间件的注册。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseWebSocketPush</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    app.UseMiddleware<WebSocketPush>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Redis打造的消息队列"><a href="#Redis打造的消息队列" class="headerlink" title="Redis打造的消息队列"></a>Redis打造的消息队列</h1><p>  OK，在编写“消息推送”中间件的时候，我们会注意到，我们使用了一个名为SimpleMessageQueue的类来取得消息，而服务端会负责将该消息群发到所有的客户端。这个其实就是博主写的一个简单的消息队列啦，如此简洁直白的命名证明它的确非常简单。有多简单呢？我想一会儿大家就会找到答案。在此之前，我想和大家讨论这样一个问题。其实，聊天室和弹幕挺像的吧，理论上服务端接收到客户端发的消息，就可以直接群发过去啊，为什么要搞一个消息队列在这里呢？而且更扯的一点是，既然博主你选择用Redis啦，你难道不知道Redis天生就支持发布订阅(<strong>Pub-Sub</strong>)吗？为什么要搞一个消息队列在这里呢？</p><p>  对这个问题，我的想法其实是这样的，我最初想做的是：后端定期推送数据到前端，再由前端通过这些数据来绘制图表。此时，无论后端还是前端，其实都是数据的消费者，这些数据当然不能一股脑儿全给它们啊，这吃撑着了可怎么办，所以，为了避免它们消化不良，我得有一个东西帮助它维持秩序啊，这就是消息队列啊。简单来说，如果数据量超过程序的处理能力，这个时候我们就需要消息队列在前面帮忙“挡”一下。想象一下，如果去银行办理业务的人，都不排队一股脑儿涌向柜台，银行柜员大概会感到崩溃。我们的程序模拟的是现实生活，所以，我们需要消息队列。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05kt1cubj20j0091t8s.jpg" alt="为什么需要消息队列" title>                </div>                <div class="image-caption">为什么需要消息队列</div>            </figure><p>  那么，有朋友要问啦，就算你要用消息队列，那博主你为什么不用RibbitMQ，再不济可以考虑微软自带的MQ啊，为什么要用Redis做一个MQ呢？就算你坚持要用Redis做MQ，为什么不考虑用的Redis的发布-订阅(<strong>Pub-Sub</strong>)呢？对于第一个问题，你可以理解为我穷或者懒(<strong>穷个什么鬼啊，你特么就是懒<em>(:з」∠)</em></strong>)。我就是懒得去搞RabbitMQ，谁让我电脑C盘都快爆炸了呢，自从我把玩了几次<strong>Docker for Windows</strong>以后，而且我们项目上还真有不被允许用MQ的情况。所以，基于以上原因，我选择了Redis。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05edd27tj209l06njre.jpg" alt="Redis中的Pub-Sub" title>                </div>                <div class="image-caption">Redis中的Pub-Sub</div>            </figure><p>  那么，为什么不用发布-订阅(<strong>Pub-Sub</strong>)呢，因为观察者模式的一个前提是，订阅者和主题必须在同一个上下文，即消息的发送方和接受方都必须同时“在线”。可Bilibili的弹幕和用户的在线与否无关，这意味着发弹幕与接收弹幕可以不在同一个时刻，所以，在设计上我们是提供了一个API接口来发送弹幕，而不是直接通过WebSocket来发送。否则，消息都到达服务端了，再通过一个消息队列来取消息，这就真的有点奇怪了不是吗？</p><p>  下面给出这个消息队列的实现，原理上是这样的，每一个消息所在的Channel，实际上都是一个列表，我们使用Channel的名称作为这个列表的键。接下来，ServiceStack提供的Redis客户端中，提供了名为BlockingListItem()的方法，它可以提供类似消息队列的功能，我们在这个基础上实现了一个简单的消息队列。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMessageQueue</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _connectionString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> BasicRedisClientManager _clientManager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageQueue</span>(<span class="params"><span class="keyword">string</span> connectionString</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        _connectionString = connectionString;</span><br><span class="line">        _clientManager = <span class="keyword">new</span> BasicRedisClientManager(_connectionString);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">string</span> channel, <span class="keyword">string</span> messsage</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        {</span><br><span class="line">            client.PushItemToList(channel, messsage);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="keyword">string</span> channel, IEnumerable<<span class="keyword">string</span>> messages</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        {</span><br><span class="line">            client.AddRangeToList(channel, messages.ToList());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Pull</span>(<span class="params"><span class="keyword">string</span> channel,TimeSpan interval</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _clientManager.GetClient())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> client.BlockingDequeueItemFromList(channel,interval);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相应地，在WebSocketPush中间件中，我们通过Pull()方法来取得消息，时间间隔为2s。在MessageController中，我们提供了用以发送弹幕的API接口，它实际上调用了Push()方法，这个非常简单啦，我们不再做详细说明。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"/api/message/publish/barrage"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Publish</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Stream stream = HttpContext.Request.Body;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[HttpContext.Request.ContentLength.Value];</span><br><span class="line">    stream.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">    <span class="keyword">string</span> message = System.Text.Encoding.UTF8.GetString(buffer);</span><br><span class="line">    _redisPublisher.Push(<span class="string">"barrage"</span>, message);</span><br><span class="line">    Response.Headers.Add(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="使用Canvas绘制弹幕"><a href="#使用Canvas绘制弹幕" class="headerlink" title="使用Canvas绘制弹幕"></a>使用Canvas绘制弹幕</h1><p>  好啦，截止到目前为止，我们所有后端的开发已基本就绪。现在，我们来关注下前端的实现。关于WebSocket原生API的使用，在上一篇文章中，我们已经讲过啦，这里我们重点放在客户端提交弹幕以及绘制弹幕。</p><p>  首先来说，客户端提交弹幕到服务器，因为我们已经编写了相应的Web API，所以这里我们简单调用下它就好。和上一篇文章一样，我们继续使用Vue作为我们的前端框架，这对一个不会写ES6和CSS的伪前端来说，是非常友好的一种体验。因为现在是2018年，所以，我们要坚决地放弃jQuery，虽然它的ajax的确很好用，可这里我们还是要使用Axios：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">"http://localhost:8002/api/message/publish/barrage"</span>,{</span><br><span class="line">    value: self.value,</span><br><span class="line">    color: self.color,</span><br><span class="line">    time: self.video.currentTime</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">})</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>  接下来，说说弹幕绘制。我们知道，HTML5中提供了基于Canvas的绘图API，所以，我们这里可以用它来完成弹幕的绘制。基本思路是：根据video标签计算出弹幕出现的范围，然后让弹幕从右侧向左逐渐移动，而弹幕的垂直位置则可以是顶部/底部/随机，当弹幕移动到屏幕左侧时，我们从弹幕集合中移除掉这个元素即可。下面给出基本代码，绘图相关的接口可以参考<a href="http://www.w3school.com.cn/tags/html_ref_canvas.asp" target="_blank" rel="noopener">这里</a>，弹幕相关参考了这篇<a href="https://www.zhangxinxu.com/wordpress/2017/09/html5-canvas-video-barrage/" target="_blank" rel="noopener">文章</a>：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">context.shadowColor = <span class="string">'rgba(0,0,0,'</span> + <span class="keyword">this</span>.opacity + <span class="string">')'</span>;</span><br><span class="line">context.shadowBlur = <span class="number">2</span>;</span><br><span class="line">context.font = <span class="keyword">this</span>.fontSize + <span class="string">'px "microsoft yahei", sans-serif'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/rgb\(/</span>.test(<span class="keyword">this</span>.color)) {</span><br><span class="line"> context.fillStyle = <span class="string">'rgba('</span> + <span class="keyword">this</span>.color.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">')'</span>)[<span class="number">0</span>] + <span class="string">','</span> + <span class="keyword">this</span>.opacity + <span class="string">')'</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"> context.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">}</span><br><span class="line">context.fillText(<span class="keyword">this</span>.value, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br></pre></td></tr></tbody></table></figure><h1 id="翻滚吧，弹幕！"><a href="#翻滚吧，弹幕！" class="headerlink" title="翻滚吧，弹幕！"></a>翻滚吧，弹幕！</h1><p>  OK，现在我们来一起看看最终的效果，如你所见，在视频播放过程中，我们可以通过视频下方的输入框发送弹幕，弹幕会首先经由Redis缓存起来，当到达一定的时间间隔以后，我们就会将消息推送到客户端，这样所有的客户端都会看到这条弹幕，而对于客户端来说，它在和服务端建立WebSocket连接以后，唯一要做的事情就是在onmessage回调中取得弹幕数据，并将其追加到弹幕数组中，关于弹幕绘制的细节，我们在本文的第三节已经做了相关说明，在此不再赘述。<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz0206huayg20jo0h3npj.gif" alt="弹幕效果展示" title>                </div>                <div class="image-caption">弹幕效果展示</div>            </figure><br>  这里，我们采用了前后端分离的设计，即使我们没有并使用主流的ES6去实现客户端。因此，这是客户端实际上是一个静态页面，在本地开发阶段，我们可以通过打开多个浏览器窗口来模拟多用户。那么，如果我们希望让更多人来访问这个页面该怎么做呢？这就要说到ASP.NET Core中的静态文件中间件。无论是IIS还是Apache，对静态页面进行展示，是一个Web服务器最基本的能力。在ASP.NET Core中，我们是通过静态文件中间件来实现这个功能，简而言之，通过这个功能，我们就可以让别人通过IP或者域名来访问wwwroot目录下的内容。具体代码如下：<p></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseDirectoryBrowser();</span><br><span class="line">app.UseStaticFiles();</span><br></pre></td></tr></tbody></table></figure><p>  当然，这里有一个细节是为了让别人可以通过IP或者域名来访问你的服务，你需要修改下WebHostBuilder中URL。此外，因为我们在前端界面中使用了绝对的URL去访问WebAPI，因此，当前端页面和WebAPI不在一个域中时，就会出现所谓垮域的问题，这方面的内容非常丰富，因为这是一个再常见不过的问题，身处在这个时代，80%的问题都已经被解决过了，这到底是我们的幸运还是不幸呢？</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">   .UseStartup<Startup>()</span><br><span class="line">   .UseUrls(<span class="string">"http://*:8002"</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  本文在<a href="https://qinyuanpei.github.io/posts/1989654282/">上一篇</a>的基础上，借助Redis和WebSocket实现了一个简单的弹幕系统。博主的初衷是想一个数据可视化的小项目，可以通过WebSocket实时地刷新图表，因为在博主看来，数据分析同样是有趣的事情。这篇文章选取博主在工作中遇到的实际场景作为切入点，试图发掘出WebSocket在实时应用方面更多的可能性。</p><p>  首先，我们编写了“消息推送”中间件，并通过不同的路由来处理各自的业务，实现了模块间的相互独立。接下来，我们讨论了Redis作为消息队列的可行性，并基于Redis编写了一个简单的消息队列。最终，通Canvas API完成客户端弹幕的绘制，实现了从后端到前端的方案整合。藉由这个小项目，可以引出ASP.NET Core相关的话题，譬如静态文件中间件、部署、跨域等等的话题，感兴趣的朋友可以自己去做进一步的了解，以上就是这篇博客的全部内容啦，谢谢大家！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Redis" scheme="https://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="WebSocket" scheme="https://qinyuanpei.github.io/tags/WebSocket/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title>长安不见使人愁</title>
    <link href="https://qinyuanpei.github.io/posts/3417652955/"/>
    <id>https://qinyuanpei.github.io/posts/3417652955/</id>
    <published>2018-08-10T20:42:23.000Z</published>
    <updated>2019-05-10T10:39:36.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  “大道如青天，我独不得出”。这是唐朝大诗人李白在《行路难》(其二)中的感慨，相比“长风破浪直济沧海”的豪迈，这首诗反而显得矫情啦，仿佛生活就应该陪着大家一起笑，我这种神经兮兮的文艺Boy，就只有这片手机屏幕大小的地方，来说些不合时宜的冷笑话。这大概是博客能让我坚持写下去的理由，因为它的的确确是属于你的，那么请原谅我，因为我要在这里写点矫情的话。</p><p>  上周一个人独自从公司办理完离职手续，原来那天下午是可以不用下班打卡的，这种感觉就好像是，你坚持并且在乎了很久的一件事情，在某一瞬间突然变得不再重要。我突然意识到，我居然已经在这个城市里生活了两年多。两年多是种什么体验呢？或许是曾经说过再见的朋友再没有见过面，又或许是曾经拒绝过你的女孩子终于结了婚，又或许是青龙寺里的樱花们开了一年又一年，又或许是遗址公园里石榴又从青色变成了红色……你脑海中的记忆越来越浅，而额头上的皱纹越来越深，记忆果真都被时间从额头上凿了去吗？</p><p>  和朋友们聊天的时候，他们一如既往地感慨着自己婚后的月光生活，一如既往地羡慕着我接近他们三倍的高薪工资，总要在聊天快要结束时侯，一如既往地问我：真的不打算回来了吗？也许，等到银西高铁通车的时候，我终于不用再坐将近12个小时的火车回家。“鸟倦飞而知还”，可我是否是《阿飞正传》里的那一只，那只没有脚的鸟，它只能够一直飞呀飞呀，飞累了就在风里睡觉。我认识的人里，有从大学时代就在这个城市驻足的人，有远离故乡在这个城市扎根的人，无一例外的是，我们都离故乡越来越远，交通的便利和发达，并不足以弥补这种心灵上的距离，就像你从地图上看各个省份好像都离得不远。可没法在一起的人们啊，连最后一步都会觉得遥远啊！我不得不承认，没有人天生会是一个无忧无虑的漂泊者，无论是洛阳还是长安，对我而言都不是故乡。</p><p>  早已忘记是从什么时候开始不吃辣的，真正令我感到神奇的，是这种习惯终于让我带去到不同的城市，就像你很难说清楚，喜欢一个人有多少是来自喜欢，又有多少是来自习惯。周末基本固定的去书店看书，看书的同时亦看匆匆的行人。小寨和钟楼永远不乏光鲜亮丽的男男女女，俨然是这个城市里最繁华的地带，人们的自拍无一不透露着时尚与精致，在某一瞬间，让我这个来自三四线小城市的人，相形见绌到沉默不言。想象下大唐盛世里的长安城，最繁华的市集无外东西两市，马亲王的《长安十二时辰》所展现的盛唐风物，对真实的历史而言，不过是雪泥鸿爪、惊鸿一瞥。如今西市为商业街所包围，一座大唐西市博物馆悄立其中，其形堪称寂寥否？西安遍地都是商场、购物中心，其盛堪比大唐否？</p><p>  我曾经开玩笑地和朋友说，我现在喜欢观察路上行人们的穿搭，仿佛这样能让我喜欢的女孩子愿意看我一眼，朋友不无嘲讽地说，“你这是在东施效颦啊”，就连我喜欢的女孩子都说，“每个人都会有自己喜欢的风格啊”。可其实，我只有一点能确定，我明确知道我不喜欢那种风格，倘若真要问我喜欢什么，我真的不知道啊！不要以为只有女孩子，会在面对琳琅满目的商品时选择困难，在这个选择多样化的时代，明确知道自己想要什么，对每一个人而言，反倒是一种相当稀缺的品质。就像人只有长大了以后才会明白，做一个优秀的男人是多么困难的事情，做学生的时候比的是学习成绩，做男人的时候则是比社会化综合测评。初到长安“居之不易”的白居易，和此时的你我是何其相似，彼时长安是大唐的首都，此时西安是新新一线城市，历史啊，果然都是相似的嘛，所不同的只是当事人。</p><p>  朋友们都希望我可以“自信”点，可终于有这样一天，你做到了曾经想做而不敢做的事情，这一切又是否真的会如你所愿。人啊，总是情愿活在借口里。我有位朋友常常“一语惊人”，简直就是“语不惊人死不休”的典型代表，他说，“不管男人的话还是女人的话，都不要相信”。大意就是说，人家就是那么随口一说，你这还当真了不是。姜文《让子弹飞》里有一个情节，小六子被诬陷吃了两碗凉粉却给了一碗凉粉钱，百口莫辩的小六子，不得已剖开肚子来自证清白。其实，世上好多事情都是没有道理的，你证明了你可以做到某一件事情又能怎么样呢？时过境迁，当一切都重新归于平静，也许人家就是那么随口一说，也许人家早都忘记了说过这句话，而你却守着这个可笑的执念等到花儿都谢了。人呐，偶尔狠下心来，是因为这样很爽吗？就像人们喜欢暴力一样。其实，真正的自信应该是温柔的，很多时候你以为的自信，无非是任性罢了。一个小孩子，会因为你帮他捡起掉在地上的扇子，而对你微笑，即使他还不会说话。</p><p>  有时候，我会想人们对于一件事物的评价标准为何会存在差异，这是否是因为我们根本不了解自己。人类其实和猴子差不了多少，对这个世界总是充满好奇，似乎什么都想要去尝试。喜欢吃喝玩乐会被认为是懂得享受生活，而喜欢独处内省则会被认为是乏味无趣，可其实大家都是第一次做人，都是第一次面对这个存活了上亿年的星球。当北极圈里开始出现30度的高温，大概在这个世界上并不存在绝对的事情。当所有的标准都被满足，这是否意味着无论对方是谁都可以，我们明明都在执着于找寻唯一的东西，却为何选择了原本和唯一无关的标准。因为但凡有标准存在的地方，它们就注定难以成为独一无二的东西。就像《小偷家族》里的“父亲”，自认为什么都不会除了盗窃，却教会了祥太关于青春期的一切。很多时候爱不像我们想象地拥有一个标准模板，就像这个并不“标准”的家庭，却拥有足以打动我们的情感一样。或许，追求“标准”本来就是件愚蠢的事情，我们自以为个性独立，实际上永远被各种“虚拟”的东西束缚着，正如卢梭所言：“人生而自由，而无往不在枷锁之中”。</p><p>  我想，李白抒发“不见长安”的愁绪时，大抵不会想到日后遇赦时的快意，更不会想到被玄宗逐出长安时的失意。可当你真的了解了你所要面对的人生，是否还有勇气会像现在这样选择。对于我的人生，我不知道今后会是什么样子，我唯一能做的，就是接受我已经失去的一切，长安并不足以安，你会有一个可以令你心安的人出现吗？长安不见，你愿意让我见到你吗？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="西安" scheme="https://qinyuanpei.github.io/tags/%E8%A5%BF%E5%AE%89/"/>
    
      <category term="矫情" scheme="https://qinyuanpei.github.io/tags/%E7%9F%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>使用.NET Core和Vue搭建WebSocket聊天室</title>
    <link href="https://qinyuanpei.github.io/posts/1989654282/"/>
    <id>https://qinyuanpei.github.io/posts/1989654282/</id>
    <published>2018-08-01T15:42:23.000Z</published>
    <updated>2019-05-10T10:39:36.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  Hi，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天这篇博客，我们来说说WebSocket。各位可能会疑惑，为什么我会突然间对WebSocket感兴趣，这是因为最近接触到了部分“实时”的业务场景，譬如：用户希望在远程视频通话过程中，实时地监控接入方的通话状态，实时地将接入方的响应时间、通话时长以及接通率等信息推送到后台。与此同时，用户可以通过监控平台看到实时变化着的图表。坦白地讲，这种业务场景陌生吗？不，每一年的双11，都能见到小伙伴们实时地“剁手”。所以，在今天这篇文章中，我们会以WebSocket聊天室为例，来讲解如何基于WebSocket构建实时应用。</p><h1 id="WebSocket概述"><a href="#WebSocket概述" class="headerlink" title="WebSocket概述"></a>WebSocket概述</h1><p>  WebSocket是HTML5标准中的一部分，从Socket这个字眼我们就可以知道，这是一种网络通信协议。WebSocket是为了弥补HTTP协议的不足而产生的，我们知道，HTTP协议有一个重要的缺陷，即：请求只能由客户端发起。这是因为HTTP协议采用了经典的请求-响应模型，这就限制了服务端主动向客户端推送消息的可能。与此同时，HTTP协议是无状态的，这意味着连接在请求得到响应以后就关闭了，所以，每次请求都是独立的、上下文无关的请求。这种单向请求的特点，注定了客户端无法实时地获取服务端的状态变化，如果服务端的状态发生连续地变化，客户端就不得不通过“轮询”的方式来获知这种变化。毫无疑问，轮询的方式不仅效率低下，而且浪费网络资源，在这种背景下，WebSocket应运而生。</p><p>  WebSocket协议最早于2008年被提出，并于2011年成为国际标准。目前，主流的浏览器都已经提供了对WebSocket的支持。在WebSocket协议中，客户端和服务器之间只需要做一次握手操作，就可以在客户端和服务器之间实现双向通信，所以，WebSocket可以作为<strong><a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="noopener">服务器推送</a></strong>的实现技术之一。因为它本身以HTTP协议为基础，所以对HTTP协议有着更好的兼容性，无论是通信效率还是传输的安全性都能得到保证。WebSocket没有同源限制，客户端可以和任意服务器端进行通信，因此具备通过一个单一连接来支持上下游通信的能力。从本质上来讲，WebSocket是一个在握手阶段使用HTTP协议的TCP/IP协议，换句话说，一旦握手成功，WebSocket就和HTTP协议再无瓜葛，下图展示了它与HTTP协议的区别：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy4vzaqgj20hg0e7q3d.jpg" alt="HTTP与WebSocket的区别" title>                </div>                <div class="image-caption">HTTP与WebSocket的区别</div>            </figure><h1 id="构建一个聊天室"><a href="#构建一个聊天室" class="headerlink" title="构建一个聊天室"></a>构建一个聊天室</h1><p>  OK，在对WebSocket有了一个基本的认识以后，接下来，我们以一个最简单的场景来体验下WebSocket。这个场景是什么呢？你已经知道了，答案就是网络聊天室。这是一个非常典型的实时场景。这里我们分为服务端实现和客户端实现，其中：服务端实现自豪地采用.NET Core，而客户端实现采用Vue的双向绑定特性。现在是公元2018年了，当jQuery已成往事，操作DOM这种事情交给框架去做就好，而且我本人很喜欢MVVM这种模式，Vue的渐进式框架，非常适合我这种不会写ES6的伪前端。</p><h2 id="NET-Core与中间件"><a href="#NET-Core与中间件" class="headerlink" title=".NET Core与中间件"></a>.NET Core与中间件</h2><p>  关于.NET Core中对WebSocket的支持，这里主要参考了<a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-2.1" target="_blank" rel="noopener">官方文档</a>，在这篇文档中，演示了一个最基本的Echo示例，即服务端如何接收客户端消息并返回消息给客户端。这里，我们首先需要安装<strong>Microsoft.AspNetCore.WebSockets</strong>这个库，直接通过Visual Studio Code内置的终端安装即可。接下来，我们需要在<strong>Startup</strong>类的<strong>Configure</strong>方法中添加WebSocket中间件：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseWebSockets()</span><br></pre></td></tr></tbody></table></figure><p></p><p>更一般地，我们可以配置以下两个配置，其中，KeepAliveInterval表示向客户端发送Ping帧的时间间隔；ReceiveBufferSize表示接收数据的缓冲区大小：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocketOptions = <span class="keyword">new</span> WebSocketOptions()</span><br><span class="line">{</span><br><span class="line">    KeepAliveInterval = TimeSpan.FromSeconds(<span class="number">120</span>),</span><br><span class="line">    ReceiveBufferSize = <span class="number">4</span> * <span class="number">1024</span></span><br><span class="line">};</span><br><span class="line">app.UseWebSockets(webSocketOptions);</span><br></pre></td></tr></tbody></table></figure><p>  好了，那么怎么接收一个来自客户端的请求呢？这里以官方文档中的示例代码为例来说明。首先，我们需要判断下请求的地址，这是客户端和服务端约定好的地址，默认为<strong>/</strong>，这里我们以<strong>/ws</strong>为例；接下来，我们需要判断当前的请求上下文是否为WebSocket请求，通过<strong>context.WebSockets.IsWebSocketRequest</strong>来判断。当这两个条件同时满足时，我们就可以通过<strong>context.WebSockets.AcceptWebSocketAsync()</strong>方法来得到WebSocket对象，这样就表示“握手”完成，这样我们就可以开始接收或者发送消息啦。<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.Request.Path == <span class="string">"/ws"</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (context.WebSockets.IsWebSocketRequest)</span><br><span class="line">    {</span><br><span class="line">        WebSocket webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p></p><p>  一旦建立了Socket连接，客户端和服务端之间就可以开始通信，这是我们从Socket中收获的经验，这个经验同样适用于WebSocket。这里分别给出WebSocket发送和接收消息的实现，并针对代码做简单的分析。<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> Task SendMessage<TEntity>(WebSocket webSocket, TEntity entity)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> Json = JsonConvert.SerializeObject(entity);</span><br><span class="line">    <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(Json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.SendAsync(</span><br><span class="line">        <span class="keyword">new</span> ArraySegment<<span class="keyword">byte</span>>(bytes),</span><br><span class="line">        WebSocketMessageType.Text,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        CancellationToken.None</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  这里我们提供一个泛型方法，它负责对消息进行序列化并转化为byte[]，最终调用<strong>SendAsync()</strong>方法发送消息。与之相对应地，客户端会在<strong>onmessage()</strong>回调中就会接受到消息，这一点我们放在后面再说。WebSocket接收消息的方式，和传统的Socket非常相似，我们需要将字节流循环读取到一个缓存区里，直至所有数据都被接收完。下面给出基本的代码示例：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> ArraySegment<<span class="keyword">byte</span>>(<span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize]);</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> webSocket.ReceiveAsync(buffer, CancellationToken.None);</span><br><span class="line"><span class="keyword">while</span> (!result.EndOfMessage)</span><br><span class="line">{</span><br><span class="line">result = <span class="keyword">await</span> webSocket.ReceiveAsync(buffer, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = Encoding.UTF8.GetString(buffer.Array);</span><br><span class="line">json = json.Replace(<span class="string">"\0"</span>, <span class="string">""</span>).Trim();</span><br><span class="line"><span class="keyword">return</span> JsonConvert.DeserializeObject<TEntity>(json, <span class="keyword">new</span> JsonSerializerSettings()</span><br><span class="line">{</span><br><span class="line">    DateTimeZoneHandling = DateTimeZoneHandling.Local</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>  虽然不大清楚，为什么这里反序列化后的内容中会有大量的<strong>\0</strong>，以及这个全新的类型ArraySegment到底是个什么鬼，不过程序员的一生无非都在纠结这样两个问题，“it works” 和 “it doesn’t works”，就像人生里会让你纠结的无非是”她喜欢你“和”她不喜欢我“这样的问题。有时候，这样的问题简直就是玄学，五柳先生好读书而不求甚解，我想这个道理在这里同样适用，截止到我写这篇博客前，这个代码一直工作得很好，所以，这两个问题我们可以暂时先放在一边，因为眼下还有比这更为重要的事情。</p><p>  通过这篇<a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-2.1" target="_blank" rel="noopener">文档</a>，我们可以非常容易地构建出一个”实时应用“，可是它离我们这篇文章中的目标依然有点距离，如果各位足够细心的话，就会发现这样一个问题，即示例中的代码都是写在<strong>app.Use()</strong>方法中的，这样会使我们的Startup类显得臃肿，而熟悉OWIN或者ASP.NET Core的朋友，就会知道Startup类是一个非常重要的东西，我们通常会在这里配置相关的组件。在ASP.NET Core中，我们可以通过<strong>Configure()</strong>方法来为<strong>IApplicationBuilder</strong>增加相关组件，这种组件通常被称为中间件。那么，什么是中间件呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixy9ja6ij20go0ao3z9.jpg" alt="中间件示意图" title>                </div>                <div class="image-caption">中间件示意图</div>            </figure><p>  从这张图中可以看出，中间件实际上是指在HTTP请求管道中处理请求和响应的组件，每个组件都可以决定是否要将请求传递给下一个组件，比如身份认证、日志记录就是最为常见的中间件。在ASP.NET Core中，我们通过app.Use()方法来定义一个Func<RequestDelegate,RequestDelegate>类型的参数，所以，我们可以简单地认为，在ASP.NET Core中，Func<RequestDelegate,RequestDelegate>就是一个中间件，而通过app.Use()方法，这些中间件会根据注册的先后顺序组成一个链表，每一个中间件的输入是上一个中间件的输出，每一个中间件的输出则会成为下一个中间件的输入。简而言之，每一个RequestDelegate对象不仅包含了自身对请求的处理，而且包含了后续中间件对请求的处理，我们来看一个简单的例子：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.Use(<span class="keyword">async</span> (context,next)=></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第一个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.Use(<span class="keyword">async</span> (context,next)=></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第二个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.Use(<span class="keyword">async</span> (context,next)=></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"这是第三个中间件\r\n"</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p></p><p>  通过Postman或者任意客户端发起请求，我们就可以得到下面的结果，现在想象一下，如果我们在第一种中间件中不调用next()会怎么样呢？答案是中间件之间的链路会被打断，这意味着后续的第二个、第三个中间件都不会被执行。什么时候我们会遇到这种场景呢？当我们的认证中间件认为一个请求非法的时候，此时我们不应该让用户访问后续的资源，所以直接返回403对该请求进行拦截。在大多数情况下，我们需要让请求随着中间件的链路传播下去，所以，对于每一个中间件来说，除了完成自身的处理逻辑以外，还至少需要调用一次next()，以保证下一个中间件会被调用，这其实和职责链模式非常相近，可以让数据在不同的处理管道中进行传播。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05nfs2htj213t078mxj.jpg" alt="ASP.NET Core中间件示例" title>                </div>                <div class="image-caption">ASP.NET Core中间件示例</div>            </figure><p>  OK，这里我们继续遵从这个约定，将整个聊天室相关的逻辑写到一个中间件里，这样做的好处是，我们可以将不同的WebSocket互相隔离开，同时可以为我们的Startup类”减负“。事实证明，这是一个正确的决定，在开发基于WebSocket的弹幕功能时，我们就是用这种方式开发了新的中间件。这里，我们给出的是WebSocketChat中间件中最为关键的部分，详细的代码我已经放在<a href="https://github.com/qinyuanpei/dotnetcore-pritices" target="_blank" rel="noopener">Github</a>上啦，大家可以参考<a href="https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/hello-webapi-1/Middlewares/WebSocketChat.cs" target="_blank" rel="noopener">WebSocketChat</a>类，其基本原理是：使用一个字典来存储每一个聊天室中的会话(Socket)，当用户打开或者关闭一个WebSocket连接时，会向服务器端发送一个事件(Event)，这样客户端中持有的用户列表将被更新，而根据发送的消息，可以决定这条消息是被发给指定联系人还是群发：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (!IsWebSocket(context))</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userName = context.Request.Query[<span class="string">"username"</span>].ToArray()[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">await</span> context.WebSockets.AcceptWebSocketAsync();</span><br><span class="line">    <span class="keyword">while</span> (webSocket.State == WebSocketState.Open)</span><br><span class="line">    {</span><br><span class="line">         <span class="keyword">var</span> entity = <span class="keyword">await</span> Receiveentity<MessageEntity>(webSocket);</span><br><span class="line">         <span class="keyword">switch</span> (entity.Type)</span><br><span class="line">         {</span><br><span class="line">             <span class="keyword">case</span> MessageType.Chat:</span><br><span class="line">                  <span class="keyword">await</span> HandleChat(webSocket, entity);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> MessageType.Event:</span><br><span class="line">                  <span class="keyword">await</span> HandleEvent(webSocket, entity);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">         }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">"Close"</span>, <span class="keyword">default</span>(CancellationToken));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  其中，HandleEvent负责对事件进行处理，HandleChat负责对消息进行处理。当有用户加入聊天室的时候，首先会向所有客户端广播一条消息，告诉大家有新用户加入了聊天室，与此同时，为了让大家可以和新用户进行通信，必须将新的用户列表推送到客户端。同理，当有用户离开聊天室的时候，服务器端会有类似的事件推送到客户端。事件同样是基于消息来实现的，不过这两种采用的数据结构不同，具体大家可以通过源代码来了解。发送消息就非常简单啦，给指定用户发送消息是通过用户名来找WebSocket对象，而群发消息就是遍历字典中的所有WebSocket对象，这一点我们不再详细说啦！</p><h2 id="Vue驱动的客户端"><a href="#Vue驱动的客户端" class="headerlink" title="Vue驱动的客户端"></a>Vue驱动的客户端</h2><p>  在实现服务端的WebSocket以后，我们就可以着手客户端的开发啦！这里我们采用原生的WebSocket API来开发相关功能。具体来讲，我们只需要实例化一个WebSocket类，并设置相应地回调函数就可以了，我们一起来看下面的例子：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="string">"PayneQin"</span></span><br><span class="line"><span class="keyword">var</span> websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8002/ws?username="</span> + username);</span><br></pre></td></tr></tbody></table></figure><p>  这里我们使用<strong>/s</strong>这个路由来访问WebSocket，相应地，在服务端代码中我们需要判断<strong>context.Request.Path</strong>，WebSocket在握手阶段是基于HTTP协议的，所以我们可以以QueryString的形式给后端传递一个参数，这里我们需要一个用户名，它将作为服务端存储WebSocket时的一个键。一旦建立了WebSocket，我们就可以通过回调函数来监听服务器端的响应，或者是发送消息给服务器端。主要的回调函数有onopen、onmessage、onerror和onclose四个，基本使用方法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接成功"</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"接收到服务端消息："</span> + event.data)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接发生错误"</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket连接关闭"</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>  原生的WebSocket API只有两个方法，即send()和close()，这两个方法非常的简单，我们这里不再说明。需要说明的是，客户端使用了Vue来做界面相关的绑定，作为一个不会写CSS、不会写ES6的伪前端，我做了一个相当简洁(简陋)的前端页面，下面给出主要的页面结构，ViewModel层的代码比较多，大家可以参考<a href="https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/client/websocket/index.html" target="_blank" rel="noopener">这里</a>：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    Hi，{{ username }}。欢迎来到WebSocket聊天室！</span><br><span class="line">    <span class="tag"><<span class="name">hr</span>/></span> 发送给：</span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"sendTo"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"All"</span>></span>全部<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"user in userList"</span> <span class="attr">:value</span>=<span class="string">"user"</span>></span>{{user}}<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">select</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">hr</span>/></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> /></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sendMessage"</span>></span>发送消息<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">hr</span>/></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"openWebSocket"</span>></span>打开WebSocket连接<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"closeWebSocket"</span>></span>关闭WebSocket连接<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"clearMessageList"</span>></span>清空聊天记录<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">hr</span>/></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messageList"</span> <span class="attr">v-html</span>=<span class="string">"messageList"</span>></span></span><br><span class="line">        {{ messageList }}</span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p>  下面是实际的运行效果，果然是非常简洁呢，哈哈<span class="github-emoji" style="color: transparent;background:no-repeat url(https://assets-cdn.github.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05jy4qvpj20wa0flq50.jpg" alt="WebSocket聊天室展示" title>                </div>                <div class="image-caption">WebSocket聊天室展示</div>            </figure><h2 id="再看Websocket"><a href="#再看Websocket" class="headerlink" title="再看Websocket"></a>再看Websocket</h2><p>  好了，我们花了如此大的篇幅来讲WebSocket，那么你对WebSocket了解了多少呢？或许通过这个聊天室的实例，我们对WebSocket有了一个相对直观的认识，可你是否想过换一个角度来认识它呢？我们说过，WebSocket是以HTTP协议为基础的，那么至少可以在握手阶段捕获到相关请求吧！果断在Chrome中打开”开发者工具“，在面板上选择监听”WebSocket”，然后我们就会得到下面的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05docrh3j219i0cydgl.jpg" alt="WebSocket的秘密-请求" title>                </div>                <div class="image-caption">WebSocket的秘密-请求</div>            </figure><p>  相比HTTP协议，WebSocket在握手阶段的请求有所变化，主要体现在Upgrade、Connection这两个字段，以及Sec-WebSocket系列的这些字段。下面来分别解释下这些字段的含义，Upgrade和Connection这两个字段，是最为关键的两个字段，它的目的是告诉Apache、Nginx这些服务器，这是一个WebSocket请求。接下来，是Sec-WebSocket-Key、Sec-WebSocket-Protocol和Sec-WebSocket-Version这三个字段，其中Sec-WebSocket-Key是一个由浏览器采用Base64算法随机生成的字符串，目的是验证服务器是否真的支持WebSocket；Sec-WebSocket-Protocol则是一个由用户指定的字符串，目的是区分同一URL下，不同服务所需要的协议；Sec-WebSocket-Version是告诉服务器浏览器支持的WebSocket版本，标准规定9-12的版本号是保留字段，所以在这里我们看到的版本号是13.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz01z8ty8kj211l05xmx6.jpg" alt="WebSocket的秘密-响应" title>                </div>                <div class="image-caption">WebSocket的秘密-响应</div>            </figure><p>  那么，对于这个浏览器发起的这个请求，服务端是如何做出响应的呢？这就要来看看服务端返回的内容。 和客户端发起的请求类似，服务端返回的内容中依然会有Upgrade和Connection这两个字段，它们和请求中的含义是完全一致的。这里需要说明的是Sec-WebSocket-Accept这个字段，我们前面提到，浏览器会通过WebSocket-Key检验服务器是否真的支持WebSocket，具体怎么检验呢？是通过下面的算法。除此之外，一个特殊的地方是这个Response的状态码是101，这表示服务端说：下面我们就按照WebSocket协议来通信吧！当然，一个更为残酷的现实是，从这里开始，就不再是HTTP协议的势力范围了啊：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sec-websocket-accept = base64(hsa1(sec-websocket-key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11))</span><br></pre></td></tr></tbody></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  这篇文章选取了“实时应用”这样一个业务场景作为切入点，引出了本文的主题——WebSocket。WebSocket是一种建立在HTTP协议基础上的双向通信协议，它弥补了以“请求-响应”模型为基础的HTTP协议先天上的不足，客户端无需再通过“轮询”这种方式来获取服务端的状态变化。WebSocket在完成“握手”后，即可以长连接的方式在客户端和服务端间构建双向通道，因而WebSocket可以在实时应用场景下，作为服务器推送技术的一种方案选择。本文以一个WebSocket聊天室的案例，来讲解WebSocket在实际项目中的应用，在这里我们使用ASP.NET Core来完成服务端WebSocket的实现，而客户端选用原生WebSocket API和Vue来实现，在此基础上，我们讲解了ASP.NET Core下中间件的概念，并将服务器端WebSocket以中间件的形式实现。在下一篇文章中，我们将偏重于服务器端的数据推送，客户端将作为数据展现层而存在。好了，以上就是这篇文章的全部内容啦，谢谢大家，让我们一起期待下一篇文章吧！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="WebSocket" scheme="https://qinyuanpei.github.io/tags/WebSocket/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="Vue" scheme="https://qinyuanpei.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>草食系程序员的穿搭指南</title>
    <link href="https://qinyuanpei.github.io/posts/94443781/"/>
    <id>https://qinyuanpei.github.io/posts/94443781/</id>
    <published>2018-07-25T10:11:35.000Z</published>
    <updated>2019-05-10T10:39:36.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div id="aplayer-rAeguBLI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="432821964" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>  最近一直在看《逃避虽可耻但有用》(逃げるは恥だが役に立つ)这部日剧，当我们感慨各种脑洞都满足不了人类的好奇心时，日剧依然在老老实实地讲述着故事，即使这个故事离普通人依旧很遥远。可我认为，这是一部以轻喜剧为载体的温情剧，不管你是单身、恋爱中还是已婚，你都能从这部剧中找到自己对应的部分。所以，对于这部日剧而言，我个人是推荐大家去看一看的。原谅我不肯用我贫乏的语言去评价这部电视剧，因为我相信“此中不足为外人道也”。所谓“如人饮水，冷暖自知”，感情这件事情，懂的人自然会懂，不懂的人假装懂。</p><p>  剧中男主津崎平匡是一个“典型”的程序员，因为外表无攻击性，一脸的人畜无害，而被女主森山实栗称为“草食系”男人。男主的长相在主流审美中或许谈不上帅，因为这个世界更欣赏的，是风见君这样帅气的男人。程序员群体木讷而内向的性格，其实都是大众给贴上去的标签。人们不喜欢被贴上各种标签，可人们喜欢给别人贴各种标签，因为这样子区分不同的人最省事儿。我们无法指责这个世界用五官和三观来割裂地看待一个人，我们唯一能做的，就是去改变留在人们心中的刻板印象。剧中男主在很多方面是比我们优秀的，向他学习不能保证我们会娶到Gakki，可能让我们变得更优秀。</p><p>  好了，下面就由我带大家一起来盘点男主在剧中的穿搭，所以，这是一篇总结向的草食系程序员穿搭指南。考虑到这部剧中室内场景比室外场景更多，季节主要集中在秋冬季，所以，我们将从环境、季节、种类等多个维度，对男主在剧中的穿搭进行盘点。活在一个看脸的时代最大的悲哀就是，那些长得比你好看，明明可以靠颜值，非要靠才华的人，永远都比你更努力。虽然津崎先生经常被人说“低情商”和“屌丝”，可我相信他比我们大多数“屌丝”要优秀得多。当然，这些优点需要大家在剧中去发掘。我只是希望，通过这种方式来提升自我。面对来自这个世界的恶意，争辩是没有意义的，你只能努力去纠正这种偏见。</p><h1 id="室内篇"><a href="#室内篇" class="headerlink" title="室内篇"></a>室内篇</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzhtsrwj20sg0g0gng.jpg" alt="20180724012456548-101-2018725" title>                </div>                <div class="image-caption">20180724012456548-101-2018725</div>            </figure><p>1、深蓝色衬衣 + 深绿色休闲裤。作为职场日常穿搭，在第一集中出现，中年已婚男士池日在男主津崎面前炫耀“爱妻便当”，高情商的田沼先生替男主解围，安慰男主要好好吃饭。建议搭配：休闲皮鞋 + 一条优质皮带。同样地，我想说的是，一个人更要好好吃饭。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzjfv6pj20sg0g075g.jpg" alt="20180724012544572102-2018725" title>                </div>                <div class="image-caption">20180724012544572102-2018725</div>            </figure><p>2、蓝色衬衣 + 西裤，俨然是雇主与雇员的上下级关系。女主森山实栗通过试用期考核，指令清晰、有条不紊给女主留下良好印象。作为职场常规搭配，搭配黑框眼睛，给人一种斯文儒雅的感觉，建议根据个人肤色，选择合适的颜色，具体来讲，如果你皮肤较白，建议选择明亮的色彩；如果你皮肤较黑，建议选择中性的色彩。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzljks6j20sg0g0dgs.jpg" alt="20180724012633880103-2018725" title>                </div>                <div class="image-caption">20180724012633880103-2018725</div>            </figure><p>3、因为业务需求发生变更，男主被公司安排加班，在大家的共同努力下，项目终于按时完成，男主小心翼翼地在同事面前测试程序，衬衣领口的双色纹路，避免了视觉上的枯燥感，同事们在身后欢呼，男主深藏功与名，穿一件白衬衣，幻想自己是阿泰尔，千军万马避白袍，写程序没有Bug。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzn94otj20sg0g0tak.jpg" alt="20180724012656554104-2018725" title>                </div>                <div class="image-caption">20180724012656554104-2018725</div>            </figure><p>4、每个程序员都会有一件格子衬衫，仙剑之父姚壮宪更是穿了一辈子格子衬衫。讲道理，男主穿格子衬衫难看吗？为什么程序员穿格子衬衫和特步鞋就要被黑到异次元呢？其实，只要不是浮夸的大格子衬衫，穿起来一样萌萌哒，关键是合体！当然，只要一胖就完啦。所以，穿搭是技巧，健身是根本啊。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzoxixej20sg0g0wfu.jpg" alt="20180724012839470105-2018725" title>                </div>                <div class="image-caption">20180724012839470105-2018725</div>            </figure><p>5、女人变美只需要一只口红，而男人变帅只需要一条领带。男女主决定协议结婚后，召集双方父母商议结婚事宜。一套贴合肩线的西装，搭配一件白色衬衫，视觉上给人成熟稳重的感觉，男主虽然在剧中表现得很“怂”，可这并不影响他的“帅”啊，这套衣服最多算彩排，真正的新郎礼服请关注第11集……(嗯，这是最后一集，日剧追起来很快呦)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzqkobzj20sg0g0dh0.jpg" alt="20180724012746230106-2018725" title>                </div>                <div class="image-caption">20180724012746230106-2018725</div>            </figure><p>6、简洁到不能再简洁的短袖衬衣 + 牛仔裤。前一秒的踌躇满志，同下一秒的惊慌失措，莫名地戳中萌点，明明同事就在眼前，非要学人家卷福发短信。请女生们不要再吐槽男生穿衣服“土”，你告诉我，除了长裤和短裤我们还有什么？对了，短裤是不能穿的哦……，尤其是花花绿绿的那种🙃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzsbsbsj20sg0g0q4l.jpg" alt="20180724012906742107-2018725" title>                </div>                <div class="image-caption">20180724012906742107-2018725</div>            </figure><p>7、蓝白相间的衬衣，相比普通蓝色衬衣，平添了一种活泼的感觉，就连工牌卡的绳子都来凑热闹。你知道怎么快速从人群中识别一名程序员吗？牛仔裤 + 双肩包 + 工牌卡。不，我拒绝这种符号化的穿搭，大隐隐于市，忘了这套新手村装备吧……当然，如果你包里还是各种数据线……好像换汤不换药啊(逃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzu0aklj20sg0g0jsz.jpg" alt="20180724013156508108-2018725" title>                </div>                <div class="image-caption">20180724013156508108-2018725</div>            </figure><p>8、任何领域都会鄙视链的存在，像津崎先生这样优秀的工程师，自然远非某某培训班的学生们。如何做一名优雅的学院派呢？你需要一件毛衣或者是一件马甲，而且一定要套在衬衣上。你问我为什么这么穿，因为通常教授们都这样穿，请参考卷福主演的电影《模仿游戏》，负责破译德军恩尼格码密码机的专家们，都是这样的穿着，同样的，还有《万物李军》里剑桥的教授们……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzvnnzmj20sg0g0dhf.jpg" alt="20180724013332938109-2018725" title>                </div>                <div class="image-caption">20180724013332938109-2018725</div>            </figure><p>9、同样是毛衣和衬衣的搭配，圆领和V领是一种风格，是否翻出衬衣领又是一种风格。而我们的男主，显然可以同时驾驭这两种风格，再搭配一件休闲外套，试问还有谁？风见君帅是帅了，不过他的衣服好像永远都是针织衫啊，难道说有钱人都喜欢买一堆一样的衣服？恩，我说的就是老乔和小扎这种有钱人……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzx8mt1j20sg0g0gng.jpg" alt="20180724013332940110-2018725" title>                </div>                <div class="image-caption">20180724013332940110-2018725</div>            </figure><p>10、果然，有圆领就会有V领，强迫症对工牌卡挂绳莫名地充满好感，这个“V”字完美地贴合衣领。针织衫和衬衣，需要有一定的层次感，比如备受我们嫌弃的格子衬衫，如果搭配针织衫效果还是非常不错的，唯一的要求或许是肩膀不能过宽，因为这样会显得整体线条僵硬。我有一个问题，像女主这样宽肩膀的女生，穿一字肩真的不怕滑下来吗？😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fzixzyxno1j20sg0g03zw.jpg" alt="20180724013332943111-2018725" title>                </div>                <div class="image-caption">20180724013332943111-2018725</div>            </figure><p>11、这种“假领”的毛衣，穿出来同样好看，我严重怀疑，这个创意是来自上海静安区同福里的老马。如果你的脖子比较长，可以考虑尝试下高领毛衣，请注意，我不是在教你，去做一名女装大佬。话说回来，衬衣上套毛衣最大的缺点是，需要挤上衬衣最上面的扣子，所以买衬衣时，请确保可以放入两根手指，这样子不会像《杀破狼2》里的张晋一样被“帅”死。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy00njw0j20sg0g00ub.jpg" alt="20180724013332944112-1-2018725" title>                </div>                <div class="image-caption">20180724013332944112-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy02b1zyj20sg0g0jt1.jpg" alt="20180724013332946112-2-2018725" title>                </div>                <div class="image-caption">20180724013332946112-2-2018725</div>            </figure><p>12、这里分别是针织衫和毛背心搭配格子衬衫的正确示例，简而言之，衣服的搭配上需要体现出层次感，切忌选择色调过于接近的颜色，衬衣一定要修身，否则搭配毛衣会让你显得臃肿不堪。我要立一个flag，等我瘦到120斤，我就奖励自己一件针织衫。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy03zh2yj20sg0g0myl.jpg" alt="20180724013332949113-1-2018725" title>                </div>                <div class="image-caption">20180724013332949113-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy05o677j20sg0g0dgs.jpg" alt="20180724013332951113-2-2018725" title>                </div>                <div class="image-caption">20180724013332951113-2-2018725</div>            </figure><p>13、毛衣和针织衫真的是搭配率超级高的优质单品，穿出来真的非常好看。我知圆领T恤是夏天最常见的穿搭，可如果你想尝试下不同的风格，我建议你买一件衬衣或者是Polo衫或者是针织衫，这些都能带给你不一样的感觉。我一直想尝试皮夹克或者是牛仔外套，可我自我感觉不适合这样硬朗的风格，谁让我是一个温柔的蓝孩纸呢……</p><h1 id="室外篇"><a href="#室外篇" class="headerlink" title="室外篇"></a>室外篇</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziz5rff30j20sg0g0abw.jpg" alt="20180724013619267201-2018725" title>                </div>                <div class="image-caption">20180724013619267201-2018725</div>            </figure><p>1、这种材质的衣服应该很容易脏，而且大概率会让你显得臃肿(胖)，可不得不说，这一身和女主站一起挺搭的，我们学习穿搭只有两个目的，找到女朋友和不给女朋友丢脸(🙃)。作为围巾控，这身搭配我觉得可以尝试一下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziz30ptj9j20sg0g00up.jpg" alt="20180724013619269202-2018725" title>                </div>                <div class="image-caption">20180724013619269202-2018725</div>            </figure><p>2、一个男人，只要有一件合身的西装，就已经在变帅的路上迈出一大步。这一款的话，毛衣黑白两种颜色，和衬衣蓝灰白的色调蛮接近的，所以基本上看不出层次感来。其实一直不明白男主为什么如此沉闷的颜色，难道是因为向女主表白以后变成熟了吗？😂</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziz0x0wbpj20sg0g03zx.jpg" alt="20180724013619273203-2018725" title>                </div>                <div class="image-caption">20180724013619273203-2018725</div>            </figure><p>3、你看，这件衣服再次发挥了格子衬衫的伟大魅力，而在这件蓝色的针织衫的衬托下，可以明显地感觉到男主变“白”了，当90后们开始步入中年职场，不妨尝试穿一点靓丽的颜色，因为我们还可以再年轻一下。池日先生又讲了一句“名言”，你看津崎先生这震惊的小眼神。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziyxmzxmdj20sg0g075d.jpg" alt="20180724013619275204-1-2018725" title>                </div>                <div class="image-caption">20180724013619275204-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziyva9akzj20sg0g0t9e.jpg" alt="20180724013619277204-2-2018725" title>                </div>                <div class="image-caption">20180724013619277204-2-2018725</div>            </figure><p>4、这一次，男女主在众人“陪伴”下开展了一次小旅行，男主所穿的这件短袖衬衣真的是最普通的衣服，目测在某澜之家就可以找到同款，搭配这斜挎的帆布包简直是减龄神器，我真心羡慕那些三十多岁还会被认成学生的“大叔”们，在下高中刚毕业就被叫叔叔到现在，人家明明想被叫做“哥哥”😓</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziyc3lagej20sg0g0aby.jpg" alt="20180724013619279205-1-2018725" title>                </div>                <div class="image-caption">20180724013619279205-1-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy8slv74j20sg0g0jsu.jpg" alt="20180724013619281205-2-2018725" title>                </div>                <div class="image-caption">20180724013619281205-2-2018725</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy69pckhj20sg0g0taa.jpg" alt="20180724013619283205-3-2018725" title>                </div>                <div class="image-caption">20180724013619283205-3-2018725</div>            </figure><p>5、为什么这三件毛衣给人越来越帅的感觉？因为你发现它的颜色越来越纯粹，纯粹到最后就剩下一种颜色，所以，人家建议衣服上不要有Logo不无道理啊，在下有一位朋友，喜欢穿各种印有二次元图案的T恤，30多岁了永远都给人萌萌哒的感觉，你说到底听谁的好呢？总之，我计划今天买一件纯色毛衣，你呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fziy0kppcvj20sg0g0jsr.jpg" alt="20180724013619285206-2018725" title>                </div>                <div class="image-caption">20180724013619285206-2018725</div>            </figure><p>6、呃……这件应该被称为棒球衫还是夹克呢？我个人不太喜欢这种拼接的样式，我更喜欢那种纯色的简洁的夹克。说起这一集，男主因为错过女主的生日而自责，独自到商城里为女主挑选礼物，面对琳琅满目的商品，男主一脸茫然……有时，女生会嫌弃男生分不清口红色号什么的，并送给男生一个“直男”称号，其实，面对不熟悉的领域，谦虚而大方的承认就好了，我们当然是直的，难道你们喜欢弯的吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05pclcivj20sg0g0wfr.jpg" alt="20180724013619286207-2018725" title>                </div>                <div class="image-caption">20180724013619286207-2018725</div>            </figure><p>7、你一定觉得像男主这样西装革履的高薪人士，每天都是坐在电脑前喝喝咖啡写写代码。其实，我们是一群连星巴克都不舍得去的人，每一次紧急加班，都是咖啡因转换为二进制代码的过程。我们并不是不会花钱，我们在数码产品、电子设备等方面的投入，完全不亚于你们买衣服、做美甲等等。有判词云：钱多、话少、死得快</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05mlmzpzj20sg0g0js9.jpg" alt="20180724013619288208-2018725" title>                </div>                <div class="image-caption">20180724013619288208-2018725</div>            </figure><p>8、嗯，这件怎么评价呢？中规中矩的秋冬款外套。我一直有一个愿望，等瘦下来以后买件卫衣穿，因为我实在怀疑自己，穿任何套头的衣服都会显得胖。不过好在这是秋冬季节，大家一起胖呀，这种衣服应该会比较容易脏，因为在下就有一件差不多的，果然直男审美啊，呵呵🙃</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05gkbnnej20sg0g0aay.jpg" alt="20180724013619290209-2018725" title>                </div>                <div class="image-caption">20180724013619290209-2018725</div>            </figure><p>9、这个世界对长得高的人相当宽容，即使他们长得并不好看，可他们长得高穿衣服好看啊。从此刻开始，我希望你打破这种认知，谁说矮个子男生不能穿长款的衣服，男主这就是活生生的例子啊，我知道女生都喜欢175+的男生，可我希望你能找到我除了不能举高高以外的优点，女主到菜场就买了棵葱回来，男主赶紧接过来拎在手里，真是适合过日子的人啊</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz0222cff4j20sg0g0aay.jpg" alt="20180724233648400210-2018725" title>                </div>                <div class="image-caption">20180724233648400210-2018725</div>            </figure><p>10、这是整部剧出镜率最高的一套衣服。什么？你问我这是哪一集？话说，你们都不看片尾曲的吗？由男主演唱的单曲《恋》，着实为抖音贡献了大量流量，这舞蹈难道不可爱吗？这衣服难道不好看吗？我说过了，衬衣 + 背心是学院派的典型穿法，男主果然是个文艺的男孩子，他的帅你Get到了吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  这或许是我写过的最“八卦”的一篇博客啦，有时候，越是轻松的东西越容易被人接受。程序员，他们并不是情商低，并不是内向，并不是不会撩妹，仅仅是因为这个世界不单单需要娱乐精神，同样需要严谨和专注。搅动一个人的情绪，无非是分泌出某种荷尔蒙；而真正驱动这个世界的，是严格甚至苛刻的规则。面对不熟悉的领域，应该保持敬畏心，而非以标签化的定义以讹传讹；如果靠贴标签就可以给人分类，那么谁是好人谁又是坏人？谁代表了正义谁又代表了邪恶？哦哦，对了，我们不会修电脑以及做任何你认为简单的事情……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="程序员" scheme="https://qinyuanpei.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="日剧" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E5%89%A7/"/>
    
      <category term="穿搭" scheme="https://qinyuanpei.github.io/tags/%E7%A9%BF%E6%90%AD/"/>
    
  </entry>
  
  <entry>
    <title>邪不压正：本我的发现之旅</title>
    <link href="https://qinyuanpei.github.io/posts/1099762326/"/>
    <id>https://qinyuanpei.github.io/posts/1099762326/</id>
    <published>2018-07-23T10:48:48.000Z</published>
    <updated>2019-05-10T10:39:36.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  一直想约朋友去看场电影，可是要找一部两个人都喜欢看的电影，当真是一件非常困难的事情。直到遇上了姜文的新片《邪不压正》，愿望终于在这个周末达成。说到姜文的电影，总是不可避免地提到“政治隐喻”这个词汇，所以，对这部电影而言，导演自成一体的独特风格，让其在与普通商业片拉开差距的同时，更将观众推向了一个略显尴尬的境地，以至于散场时朋友的第一反应是：好像完全没有看懂。</p><p>  电影一开始，茫茫雪地里闪现出两个模糊的背影，向着雪地深处无限地延伸。而此时此刻，在火红的灯笼的映衬下，屋内一众人正忙着为师父庆贺寿辰，两位不速之客的到访，让一切瞬间化为烈焰中的修罗场。可以说，开篇这一场极具暴力美学的戏份，的确是可以吸引人眼球的戏份。姜文电影里有一种与生俱来的英雄主义，所谓的硬汉精神，于是你看到了身负东西方文化的李天然，是握着一把武士刀参与刺杀任务，而信奉武士道精神的根本一郎，果真是单刀赴会，说让三刀就是三刀。可这位武术名家，甚至连出手的机会都没有，就被手枪击中了头颅，武术在坚船利炮前又算得了什么呢？</p><p>  不知道大家有没有注意到这样一个细节，朱潜龙和根本一郎闯到师父家里时，师父说了句：没听到狗叫，这是否是因为，在向师父祝寿时，跪拜的声音掩盖了炸弹的声音。联想到《让子弹飞》里，张牧之到鹅城上任，对老百姓说，“不许跪，皇帝都没有了，没有人值得你们跪……”。同样地，朱潜龙在师父面前，一样跪得可谓是以头抢地，可下一秒子弹就在师父脑袋上留下弹孔……其实，人蠢一点没有关系，毕竟都跪了几千年，可偏偏人还有点儿坏。师父问朱潜龙为什么日本人不在日本种植鸦片，朱潜龙说日本是文明的国家。</p><p>  日本从明治维新以后，自上而下全面效仿西方国家，因为他们看到曾经最为强大的中华帝国，在鸦片和战争的侵蚀下早已满目疮痍。日本大河剧《坂上之云》里有一个片段，男主秋山真之在东京街头看到英国人欺负日本人，他愤怒地质问老师，为什么英国人在这里不讲绅士文化，他的老师不无遗憾地说，唯有强者有资格讲绅士文化。当时的日本不见得有多么文明，但那种全民参与到战争中的举动，在当时的世界格局里无出其右者，譬如日本曾担心和美国发生战争，起初民众讨论的是如何避免这场战争，后来则变成能否打赢这场战争，最后则变为如何打赢这场战争。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fyz8zy1vg4j20rs0ij123.jpg" alt="廖凡饰演的朱潜龙" title>                </div>                <div class="image-caption">廖凡饰演的朱潜龙</div>            </figure><p>  朱潜龙在影片中是一个典型的汉奸，他帮日本人种鸦片，是希望在日本人的扶持下做个傀儡皇帝。在七七事变前，日本人借助麻姑囤事件，杀死了不愿意合作的张作霖，而朱潜龙自认为是大明后裔，一心想着要反清复明，可讽刺的是，溥仪在日本人的扶持下建立了伪满洲国政权，他居然天真地相信，日本人会允许两个傀儡政权同时存在。于是，在裁缝铺里李天然看到“龙袍”，导演不无幽默地说，这是准备去参加巴黎时装周的，仔细想起来，这是否是在讽刺某位穿着“龙袍”去参加电影节的演员呢？可朕的大清都灭亡了，你反什么清复什么明嘛，真有种《天龙八部》里慕容世家妄图兴复一个灭亡100余年的大燕国的痴狂劲儿。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05pguvt4j20rs0gzqfo.jpg" alt="姜文镜头下的北平城" title>                </div>                <div class="image-caption">姜文镜头下的北平城</div>            </figure><p>  姜文一心想要还原一个老北京的全貌，可我感觉在这部电影里看到的北京整体偏“白”一点，印象最深刻的地方是，老亨得利带着儿子从火车站回来，镜头里的北京好像刚下过雪一样。可或许是我们本不了解北京，故宫那种红墙青瓦的印象是从新中国成立以后的啦。梁思诚夫妇当年在战争中保护下来的古建筑群，或许本来就是这个样子的。于是，在姜文导演的镜头里，我们看到带着京味儿的北京胡同，看到了发生过无数故事的东交民巷，看到了曲折蜿蜒的八达岭长城，看到了古香古色的钟楼牌坊。李天然在屋顶跟踪朱潜龙的汽车时，我开玩笑地对朋友说，“以后刺客信条要出中国近代史系列游戏，完全可以参考李天然这个设定”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05mtqkuhj20rs0ijjz2.jpg" alt="姜文饰演的蓝青峰" title>                </div>                <div class="image-caption">姜文饰演的蓝青峰</div>            </figure><p>  这一次姜文饰演的蓝青峰，这个角色在我看来相当复杂：想要除掉朱潜龙和根本一郎，但私底下跟这两个人都有来往；和老亨得利有25年的交情，因为李天然身份暴露对其痛下杀手；被朱潜龙禁锢在家中无法自救，个人实力强弱被敌人查探地一清二楚；作为参加过辛亥革命的前辈，有且只有李天然一个下级……凡次种种，不一而足。从他的名字，我联想到“青出于蓝而胜于蓝”以及“青峰侠”，电影里李天然的英文名字叫做布鲁斯，他和师兄比武时致敬了李小龙的《龙争虎斗》，黑色的中国传统服饰，李小龙标志性的步法动作。可其实说到底，蓝青峰在精神上是懦弱的，因为他完全不清楚自己要做什么，那时国内外形势风起云涌，可他到底能真正地依赖谁，或许连他自己都不知道，他觉得李天然对他有用，就花了十余年时间去布局，李天然不过是他的一枚棋子……</p><p>  蓝青峰的计划是让朱潜龙和根本一郎产生矛盾，朱潜龙杀死根本一郎后，再用李天然做交换。按照这个计划，李天然回国的确是来送死的，除非他可以在交换后杀死朱潜龙。蓝青峰害怕杀死根本一郎会引发战争，可从电影中来看，根本一郎并不是日军的高级军官。或许很多时候，人们都相信刺杀一两个人就可以让战争结束。全智贤在《暗杀》里说过这样一句话，“刺杀一两个日本人，能不能结束一场战争，我是不知道的，但我总要告诉人们，我们一直在战斗”。所以，即使李天然终于手刃仇人，卢沟桥的炮火依旧会在这个城市轰鸣。李天然凭借一腔热血，毫无来由地杀死了几个日本人，固然会让人激昂澎湃，可真的就是邪不压正吗？李天然的复仇，在我看来，是杀死懦弱的“自我”的过程，因为无父无母，李天然其实一直生活在“我是谁”、“我要去哪里”、“我要做什么”的自我怀疑之中，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz05gvysafj211y0lc7wh.jpg" alt="许晴饰演的唐凤仪" title>                </div>                <div class="image-caption">许晴饰演的唐凤仪</div>            </figure><p>  唐凤仪，一个愿意陪着朱潜龙做皇帝梦的女人，习惯了被男人驱使和奴役，可被李天然恶作剧般在屁股上以后，她终于明白，自己在朱潜龙心中不过是一个玩物，尤其是六国饭店里的那场戏，看似不露痕迹地打朱潜龙耳光，实则这个敢爱敢恨的女人形象立了起来，回敬李天然的“凤仪之宝”，通过关巧红给李天然通风报信，日军进城时城墙上的一跃，都是这个角色留给人的深刻印象。所谓“商女不知亡国恨，隔江犹唱后庭花”，风尘女子的这种刻板印象，在姜文的电影里是不存在的，她们不单有性感的身姿，更有热血的灵魂。侵略者端坐在石狮子上准备拍照，被从城墙上一跃而下的唐凤仪撞倒在地上，当时电影院里发出一阵笑声，可这无非是一个女子的反抗而已。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/4c36074fly1fz022hvdkuj20m60dftpm.jpg" alt="姜文对老婆是真爱" title>                </div>                <div class="image-caption">姜文对老婆是真爱</div>            </figure><p>  与之相对的关巧红，她美好得宛如江南恬静的女子，她同样是一种独特的美感，和唐凤仪这种艳丽的画风不同，她是像迷一样的女子，背后有太多故事没有说完，看似惊鸿一瞥地讲了放脚、开裁缝铺这些琐碎的事情，但永远给人一种“这个女人不简单”的感觉，她好像无论什么时候，都能找得到李天然；她好像对李天然有种莫名的情愫，可又清楚地知道自己想要做什么……喜欢上这样的女人，就像喜欢上一朵云，你看云时很近，而云看你时很远。即使到了故事的结尾，她依然像阵风飘然远去，留下原地惆怅的李天然，明明李天然爬屋顶比她要好，可要寻找她时，又要去哪里寻找呢？有时候，这像是朴树的《那些花儿》散落天涯，有时候，又像是泰戈尔的“生如夏花般灿烂，死如秋叶般静美”……</p><p>  说实话，这一次彭于晏的角色设定让人很出戏，因为这个角色本身的真实感并不强，即使他可以飞檐走壁，即使他可以躲开子弹。究其本质，是因为李天然身上有着勇敢而又懦弱的矛盾性格，未回国时，他一心想杀根本一郎和朱潜龙报仇；等回国后，他突然像被定住一般不知所措。第一次莽撞间接造成老亨得利被杀害，第二次莽撞直接导致蓝青峰被软禁。彭于晏一直都是一个“孤儿”，无论是师父、老亨得利还是蓝青峰，其实都不见得有多爱他。一个心中带着复仇愿望的人，一旦真正地手刃了仇人，他存在的意义又会是什么呢？所以，他怕自己因为复仇而变得迷茫，李天然看似身负正义之名，可对于师门武学的传承并无实际意义，相反，是那个杀死师父的朱潜龙，为师父塑像扬名，让师父成为大家所称赞的武术名家，到底谁是正？谁是邪？当周围人都是在利用你，杀了朱潜龙，李天然将失去存在感；而杀了李天然，日本人可以随时除掉朱潜龙。跪在岳飞目前的秦桧夫妇，和被塑成一条狗跪在武术名家塑像前，是否具有异曲同工之妙？普通人会在乎真相到底是什么样子的吗？</p><p>  一个再简单不过的寻找“爸爸”的故事，对于那时的中国，是否就像年轻而莽撞的李天然，在探索着“我是谁”、“我要去哪里”、“我要做什么”的终极哲学命题。亨得利父子出城遇见正在演习的日本军官，对方声称亨得利父子的驴子挡住了坦克，破坏了军方的演戏计划。亨得利父子以美国护照作为挡箭牌，日本军官不得不去找这两头驴子的晦气。多年以后，吴京在《战狼》系列里重复着美国护照和海军陆战队的老梗，只是此时的中国早已不再是那个家国积弱的中国。日本军官质问李天然为什么穿着日本和服，可彼时彼刻，根本一郎自作聪明地曲解论语中的含义，又是否是在告诉我们，从外表上模仿何其容易，可一旦要张嘴说话，就很容易被人识破。曾经日本在全面欧化的过程中，被西方人讥讽为穿着衣服的猴子，我们都曾经模仿过他人，一如今天“韩式审美”在中国流行。这是一个时代里的众生相，愿每个人都能找到“真我”，不再犹豫，不再怯懦，勇敢地面对自己，发现自己。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="https://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="https://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="邪不压正" scheme="https://qinyuanpei.github.io/tags/%E9%82%AA%E4%B8%8D%E5%8E%8B%E6%AD%A3/"/>
    
  </entry>
  
  <entry>
    <title>声明式RESTful客户端WebApiClient在项目中的应用</title>
    <link href="https://qinyuanpei.github.io/posts/380519286/"/>
    <id>https://qinyuanpei.github.io/posts/380519286/</id>
    <published>2018-07-16T09:02:35.000Z</published>
    <updated>2019-05-10T10:39:36.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  自从项目上采用敏捷开发的流程以后，我们的开发任务中出现了不少“联调”的任务，而所谓的“联调”任务，完全是拜前后端分离所赐。通常来讲，按照前后端分离的思想，我们的团队会被分成前端和后端两个组，前端负责页面内数据的展示，后端负责提供相关服务的接口。这样听起来非常合理，对吧？可问题在于，后端常常在等前端联调这些接口，因为后端不知道具体有哪些异常需要处理；同样，前端常常在等后端接口稳定，因为一旦出现问题，就会导致接口发生变更。虽然在此之前，我们早已花了一周左右的时间去讨论接口，接口文档早已伴随着API部署到线上，可我们依然需要大量的时间去沟通每个接口的细节。用一种什么样的语言来描述这种状态呢？大概就是人们并不是真的需要接口文档，因为真的不会有人去看这东西。</p><h1 id="从敏捷开发到产品架构"><a href="#从敏捷开发到产品架构" class="headerlink" title="从敏捷开发到产品架构"></a>从敏捷开发到产品架构</h1><p>  为什么会出现这种情况呢？我想，可以从三个方面来考虑，即设计不当、进度不一、沟通不畅。有时候集思广益去讨论一个接口，可能并不是一件好事，因为考虑的因素越多，问题就会变得越复杂，相应地妥协的地方就会越多。我并非不懂得做人需要适当妥协，事实是从妥协的那一刻起，我们的麻烦越来越多。有人问怎么能消灭Bug，我说消灭需求就可以了。现代人被各种各样的社交网络包围着，以至于隐私都被赤裸裸地暴露在空气中，可你很难想象人与人之间的沟通会越来越困难，难道是因为社交网络加剧了人类本身的孤独？没有人是一座孤岛，可前后端分离好像加剧了这种界限。现在动辄讲究全栈，可当你把精力都耗费在这些联系上去，你如何去追求全栈？相反，我们像电话接线员一样，在不停地切换上下文，因为我们要“敏捷”起来，可作为工程师就会知道，切换上下文需要付出相应的代价。</p><p>  我之所以提到这样一个场景，是出于对当前项目的一种整体回顾。我们的项目是一个客户端产品，但是它依然体现了前后端分离的思想。受业务背景限制，这个客户端采用了Native + Web的技术架构。如果你了解整个互联网产品形态的演变历程，就会对这种技术架构非常的了解，从曾经的Native和Web之争，到所谓的Hybrid App，再到如今的React Native及小程序，这种技术架构其实一直都存在，譬如Electron、Atom、Node-Webkit、Cordova、Ionic、VSCode等等，其实都是非常相近的技术。对应到我们的项目，我们提供了一个JSBridge来完成Native层和Web层之间的通信，而客户端的渲染实际上是由前端来完成的，所以你可以想到，我们通过一个WebView来加载页面，而平台相关的交互由C++/C#来完成，所以，理论上客户端是是一个和Electron类似的壳子(Shell)，它可以展示来自任何页面的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/system%20architecture.png" alt="以JSBridge为核心的系统架构图" title>                </div>                <div class="image-caption">以JSBridge为核心的系统架构图</div>            </figure><p>  从客户端的角度来讲，它是Native层接口的提供者，连接着平台相关的API，并集成了第三方的硬件设备，所以，理论上它是和具体业务无关的。可实际上，因为Web层不能直接和文件系统交互，所以，像上传、下载这样本该由前端调用的接口，部分地转移到了客户端这边，所以，客户端无可避免地受到后端API变化的影响，因为业务上需求存在差异，上传接口前后共发生了三次变化，所以，客户端中存在三个版本的上传，当然，我相信这是一个设计上的问题，通过改进设计可以得到完美的解决。关于上传为什么会这么复杂，感兴趣的朋友可以通过留言来一起交流。这里我想说的是什么呢？因为客户端希望与具体业务无关，所以，客户端注定是以功能来划分服务，然后通过JSBridge暴露给Web层。可是对后端的微服务架构而言，它的服务是以业务为主导的，它的一个业务就是一个接口。由此导致一个问题，后端接口的数量不断增加，客户端面临频繁地改动。</p><h1 id="不做平庸的ApiCaller"><a href="#不做平庸的ApiCaller" class="headerlink" title="不做平庸的ApiCaller"></a>不做平庸的ApiCaller</h1><p>  有很多人说，今天的编程工作变得越来越简单，对于这一点我非常认同。因为，无论是无论是语言、工具、生态、平台，都获得空前的繁荣，所以，我们大多数人的工作，可能就是调用现成的API，而少数人的工作，可能就是提供友好的API，甚至连代码你都可以在Google上找到，你唯一要做的就是Ctrl + C & Ctrl + V。当初想要改变世界的你我，突然有一天就变成了ApiCaller，甚至大多数的框架，你连底层细节都无从得知。可你真的打算做一个平庸的ApiCaller吗？至少我是不愿意的，因为在我看来，调用后端提供的API，大多数情况下都是换个URL，或者换个参数，这样的代码你写一次以后，剩下的基本就是复制和粘贴了，你可能会非常鄙视我的这种行为，可事实就是这样的，不单单我在复制，连我身边的同事都在复制。可这能怎么办啊，只要后端提供了新接口，或者是对接口进行了调整，而这些接口必须由客户端封装，我们的工作就永远不会停止，可这不过调用后端的API 而已啊！</p><p>  有时候，我们会说工作经验和工作时间未必是正相关的，因为如果我们十年都在做一件事情，那么其实和一年是没有区别的。为了避免成为一个平庸的ApiCaller，你必须思考那些真正重要的事情。怎么能降低后端API变化对客户端的影响呢？降低耦合度。怎么降低耦合度呢？依赖抽象而非依赖具体。想想WebService，它通过WSDL来对服务进行描述，而通过WSDL就可以在客户端创建代理类，一旦WebService发生变更，重新生成代理类就好。再回想一下，调用后端API会遇到那些问题？设置Header、设置Cookie 、拼接URL、拼接参数、URLEncode、SSL、JSON序列化、FormData、上传文件、编码/解码等等，是不是每一次都在处理这些问题？看到项目里用HttpWebRequest去构造Mulitpartfile结构，我忽然间觉得绝望。既然每次都是翻来覆去这些东西，为什么要用手来写？API文档构建工具可以帮助用户生成curl以及常见语言对应的代码，所以，我有理由相信，我们需要一个东西来帮助我们完成这个工作，就像WebService生成代理类一样。那么，有没有这样一个东西呢？这就是本文的主角——基于声明式的RESTful风格的客户端：<strong>WebApiClient</strong>。</p><h1 id="NET下的Retrofit：WebApiClient"><a href="#NET下的Retrofit：WebApiClient" class="headerlink" title=".NET下的Retrofit：WebApiClient"></a>.NET下的Retrofit：WebApiClient</h1><p>  WebApiClient是.NET平台下的Retrofit。要理解这句话，首先要理解Retrofit。什么是Retrofit呢？Retrofit是一个Android/Java下的网络通信库，其本身基于okHttp，熟悉Android开发的朋友，对这个库应该不会感到陌生。Retrofit帮助我们解决了上文中提到的，在请求一个Web API时会遇到的问题，并通过注解这种技术，以一种声明式的方式来定义接口。简单来说，所有你想要调用Web API都是接口中的一个方法，你通过注解来告诉Retrofit，该方法会请求哪一个Web API，参数会以什么样的形式传递过去，结果会以什么样的形式返回回来，你完全不必去写那些底层HTTP通信相关的东西，因为Retrofit会帮你在运行时实现这个接口。所以，我们说Retrofit是一种声明式的HTTP客户端。声明式我们见过相当多啦，Java里的注解，C#里的Attribute、Python里的装饰器、JavaScript里的修饰器，以及如今各种各样的双向绑定框架。下面，我们来一起看看WebApiClient这个库。</p><p>  现在，我假设你手里已经有可供调用的Web API，并且你真实地了解这些Web API是如何工作的。至此，我们需要完成的工作主要都集中在客户端，这里我们编写一个控制台应用来完成这一工作。首先，需要在项目中引入WebApiClient这个库，我们直接通过Nuget来完成安装即可(<strong>注：这里共有Laojiu.WebApiClient、WebApiClient.JIT和WebApiClient.AOT三个版本，博主使用的是Laojiu.WebApiClient</strong>)。使用WebApiClient的基本流程是：首先，定义一个继承自IHttpApiClient的接口并在接口中声明相关方法；其次，通过Attribute对接口中的方法和参数进行修饰以完成和Web API的绑定；最后，通过WebApiClient生成该接口的一个实例，而通过调用相应的实例方法就可以得到结果。这是不是和代理类的感觉非常像呢？像博主这样懒惰的人，或许连接口都不愿意亲自去写，因为我相信越是严谨的规则，就越是适合应用到自动化上面去。这样说可能无法让大家形成对WebApiClient的直观印象，那么让我们从一个简单的例子开始吧！</p><h2 id="Get请求接口"><a href="#Get请求接口" class="headerlink" title="Get请求接口"></a>Get请求接口</h2><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IValuesApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//GET http://localhost:8000/values1</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/values1"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask<<span class="keyword">string</span>> <span class="title">GetValues</span>(<span class="params"></span>)</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//GET http://localhost:8000/values1/{id}</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/values1/{id}"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask<<span class="keyword">string</span>> <span class="title">GetValue</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  在这个示例中，我们展示了WebApiClient是如何处理带参数以及不带参数的Get请求的。通过HttpGet特性，我们分别为GetValues()和GetValue()两个方法指定了请求的URL。虽然在这里我们指定一个完整的URL，可是考虑到我们Web API通常都是分布在不同的域名下，所以我们可以通过HttpHost特性来配置一个BaseURL。接口的返回值为ITask<t>，我们可以通过我们的需要指定相应的类型，在这里我们以ITask<string>为例，特别说明的是，如果服务器返回的是标准的JSON格式，那么我们可以将其映射为相应的实体结构，这就需要使用JsonReturn标特性对方法进行修饰。我们知道Get请求可以通过QueryString形式来进行传参，那么这一点在WebApiClient中如何实现呢？这就用到所谓的<strong>“平铺参数”</strong>，即我们在方法中声明的参数会被WebApiClient自动地追加到URL上面去，再不需要去手动地拼接这些参数；同理，这些参数可以用一个包装类封装起来，具体大家参考<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。</string></t></p><p>  OK，现在来看看如何调用IValuesApiCaller这个接口。我们在前面说过，WebApiClient会帮助我们生成一个IValuesApiCaller的实例，所以我们调用一个Web API的时候，关注点已然从之前的过程实现转变为接口实现，这正是我们渴望看到的局面。一个非常简洁的调用示例：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Values Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create<IValuesApiCaller>())</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke Values Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">await</span> client.GetValues().InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"results is <span class="subst">{results}</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.GetValue(<span class="number">10</span>).InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"result is <span class="subst">{result}</span>"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Post请求接口"><a href="#Post请求接口" class="headerlink" title="Post请求接口"></a>Post请求接口</h2><p>  接下来，我们再来说说Post请求接口。同样的，这里我们使用博主编写好的一个Service，我们称之为Student Service。它使用了EF Core来完成数据库的读写，它提供了一组和Student实体相关的API，这里我们使用它来作为Post请求接口的示例实现。因此，我们首先定义一个接口IStudentApiCaller：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStudentApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//GET http://localhost:8000/student</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/student"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    [<span class="meta">JsonReturn</span>]</span><br><span class="line">    ITask<List<Student>> GetAllStudents();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//POST http://localhost:8000/student</span></span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/student"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask<<span class="keyword">string</span>> <span class="title">NewStudent</span>(<span class="params">[JsonContent] Student student</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  这里重点关注接口中的第二个方法。首先，它是一个Post请求；其次，它接受一个JSON格式的文本作为它的请求体，所以我们这里使用了JsonContent特性。前面我们提到过，接口返回类型ITask<t>，可以映射为对应的实体结构。注意到GetAllStudtents()这个方法中绑定的API，它负责从数据库中查询所有的Student信息并以JSON形式返回，所以这里我们将其映射为List<student>。与此同时，你会注意到JsonReturn特性，这是在告诉WebApiClient，你希望将返回的结果映射为强类型的模型；同理，你可以使用XmlReturn特性来处理返回值为Xml的情形。除此之外，你还可以使用FormContent特性来修饰方法参数，其作用是将模型参数以key1=value1&key2=value2……的形式写入请求体中，对应于x-www-form-urlencode；更一般地，你可以使用FormField特性修饰方法参数，以form-data的形式写入请求体中。Mulitpart是博主最为讨厌的一种数据格式，请大家自己去看<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。</student></t></p><h2 id="过滤器与OAuth2"><a href="#过滤器与OAuth2" class="headerlink" title="过滤器与OAuth2"></a>过滤器与OAuth2</h2><p>  无论如何，请允许我说，这是我最喜欢的一个特性。大家会注意到，在我的示例代码中，有一个东西一直没有去说，这就是OAuth2Filter，这其实是博主自己扩展的一个特性，这意味着在请求该API前，需要通过OAuth2授权以获得身份令牌。对于这一点，我想大家都是清楚的，因为在微服务架构中，Web API是作为一种受保护的资源而存在的，所以鉴权和授权是非常重要的点。以博主的项目组为例，我们做到第三个项目的时候，整个后端的OAuth2认证服务终于实现了统一，可即使如此，每一次这种基础设施都需要联调，都要考虑到底使用哪一种授权模式。譬如，客户端是考虑把token存放在全局静态类里，而前端是考虑把token存放在Cookie里，甚至在此之前，我们连refresh_token都没有，客户端在调用Web API时天天担心token过期，于是在调用Web API时主动去刷新一次token。你问我为什么不判断一下token有没有过期，因为后端没有提供这个接口呀。其实，我想说的只有一句话，基础设施请交给框架去处理。</p><p>  WebApiClient提供了用于请求管道中的过滤器，可以让我们在请求前、请求后搞点事情。譬如，我们这里希望在请求前获取token，并将其追加到当前请求的Header里，或者是在请求前判断下token是否过期(假如后端愿意开发这个接口的话)，如果过期了就自动刷新下token，该怎么做呢？首先，我们定义一个IAuthApiCaller的接口，它负责从认证服务器上获取token，这里选择客户端模式：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:28203"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAuthApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">{</span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/oauth2/token"</span>)</span>]</span><br><span class="line">    <span class="function">ITask<<span class="keyword">string</span>> <span class="title">GetToken</span>(<span class="params">[FormField] <span class="keyword">string</span> client_id,[FormField] <span class="keyword">string</span> client_secret,[FormField] <span class="keyword">string</span> grant_type = <span class="string">"client_credentials"</span></span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  接下来，我们继承ApiActionFilterAttribute来编写OAuth2FilterAttribute，显然，它会在请求前调用IAuthApiCaller接口实例，这里我们将client_id和client_secret硬编码到代码里，单单是为了演示如何去印证这个想法，实际项目中大家可以考虑通过配置或者是传参来实现：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OAuth2FilterAttribute</span> : <span class="title">ApiActionFilterAttribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">OnBeginRequestAsync</span>(<span class="params">ApiActionContext context</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create<IAuthApiCaller>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">var</span> client_id = <span class="string">"578c06935d7f4c9897316ed50b00c19d"</span>;</span><br><span class="line">            <span class="keyword">var</span> client_secret = <span class="string">"d851c10e1897482eb6f476e359984b27"</span>;</span><br><span class="line">            <span class="keyword">var</span> result = client.GetToken(client_id, client_secret).InvokeAsync().Result;</span><br><span class="line">            <span class="keyword">var</span> json = JObject.Parse(result);</span><br><span class="line">            <span class="keyword">var</span> token = json[<span class="string">"access_token"</span>].Value<<span class="keyword">string</span>>();</span><br><span class="line">            context.RequestMessage.Headers.Authorization = <span class="keyword">new</span> AuthenticationHeaderValue(<span class="string">"Bearer"</span>,token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.OnBeginRequestAsync(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  至此，我们只需要给需要需要授权的API添加OAuth2Filter特性即可，全然不需要考虑这个token如何储存的问题。我对静态类和静态方法没有误解，仅仅是因为它是反模式的，任何全局内可以修改的成员，不管有没有人会去修改，它始终都是不安全的。在此我要表扬一下前端的同事，他们通过扩展ajax方法原型，实现了和这里类似的东西。所以说，你要多尝试去看看不同领域里的东西，抓住那些相同或者相似的本质，而不是被那些“旧酒换新瓶”的概念所迷惑，技术圈子的热闹有两种，一种是发明新的技术，一种是发明新的概念，我本人更喜欢第一种，你呢？</p><h2 id="上传与下载"><a href="#上传与下载" class="headerlink" title="上传与下载"></a>上传与下载</h2><p>  其实，上传应该是Post请求的一种类型，可是考虑到下载的时候，接口的返回类型应该是数据流，所以我决定将这两个内容一起来讲。这里我们就考虑单纯的上传，不考虑由文件和键值对混合组成的MulitpartFormDataContent，因为这种结构让我觉得厌恶。这里，我们直接通过ASP.NET Core编写了一个文件上传/下载的Service，同样地，我们首先定义IFilesApiCaller接口：<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpHost(<span class="meta-string">"http://localhost:8000"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFilesApiCaller</span> : <span class="title">IHttpApiClient</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Post http://localhost:8000/files/upload</span></span><br><span class="line">    [<span class="meta">HttpPost(<span class="meta-string">"/files/upload"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    [<span class="meta">JsonReturn</span>]</span><br><span class="line">    <span class="function">ITask<<span class="keyword">string</span>> <span class="title">Upload</span>(<span class="params">[HttpContent]List<MulitpartFile> files</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Get http://localhost:8000/files/download/{fileId}</span></span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"/files/download/{fileId}"</span>)</span>]</span><br><span class="line">    [<span class="meta">OAuth2Filter</span>]</span><br><span class="line">    <span class="function">ITask<HttpResponseMessage> <span class="title">Download</span>(<span class="params"><span class="keyword">string</span> fileId</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  在这里，上传我使用了ASP.NET Core中的IFormFile接口，并且在Postman测试通过，可是在网页上用type为file的input标签进行测试时，发现页面一直无法正常响应，不知道具体是什么原因(<strong>后来发现它完全和Postman中的请求体一样，好吧😬</strong>)，我一直不太理解ajax上传和表单上传的区别，曾经项目上用HttpWebRequest去做文件的上传，里面需要大量的字符串拼接动作去构造MulitpartFormData，只要后端上传的API发生变更，这段代码几乎就会变成不可维护的代码，幸运的是，在经过几次迭代以后，他们终于意识到了这个问题，在我的建议下，他们使用HttpClient重构了代码。在这里你会看到Download()方法的返回值类型为ITask<httpresponsemessage>，这是HttpClient中使用的数据结构。为什么我推荐大家使用这套API，因为它和ASP.NET中的数据结构是一致的，而事实是上，WebApiClient正是在HttpClient的基础上完成的，所以这里你能够想到，我将通过HttpResponseMessage来获取返回的数据流，进而完成文件的下载。一起来看下面的示例：</httpresponsemessage></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Files Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create<IFilesApiCaller>())</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke File Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> files = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">    {</span><br><span class="line">        <span class="string">@"C:\Users\PayneQin\Videos\Rec 0001.mp4"</span>,</span><br><span class="line">        <span class="string">@"C:\Users\PayneQin\Videos\Rec 0002.mp4"</span>,</span><br><span class="line">    }</span><br><span class="line">    .Select(f=><span class="keyword">new</span> MulitpartFile(f))</span><br><span class="line">    .ToList();</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Upload(files).InvokeAsync();</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> json = JArray.Parse(result);</span><br><span class="line">    <span class="keyword">var</span> fileId = ((JObject)json.First)[<span class="string">"fileId"</span>].Value<<span class="keyword">string</span>>();</span><br><span class="line">    <span class="keyword">var</span> fileName = Path.Combine(Environment.CurrentDirectory, <span class="string">"Output/Video001.mp4"</span>);</span><br><span class="line">    <span class="keyword">var</span> filePath = Path.GetDirectoryName(fileName);</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(filePath)) Directory.CreateDirectory(filePath);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> fileStram = <span class="keyword">new</span> FileStream(fileName, FileMode.Create))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> stream = <span class="keyword">await</span> client.Download(fileId).InvokeAsync();</span><br><span class="line">        stream.Content.ReadAsStreamAsync().Result.CopyToAsync(fileStram);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  这里说明的是，非常遗憾，这里的上传接口并没有被成功调用，可能我还是被MulitpartFormDataContent这种东西所困惑着，尽管我使用了WebApiClient中提供的MulitpartFile类，并且使用HttpContent特性对参数进行了修饰。(<strong>后来发现是因为我使用JsonReturn特性，可我的Action的确是返回了JSON啊，所以，我不暂时理解不了这一点</strong>😬)。我了解到的一点信息是，Spring Cloud中的Feign，一个和Retrofit极其相似的HTTP客户端，其本身并没有实现文件上传的功能，需要借助插件来实现相关功能，所以，这是否说明HTTP协议中的上传实现本身就是一个错误，因为它和form-data搅和在一起，试图用键值对的形式去描述一个文件，我们的业务中需要给文件增加备注关联相关信息，坦白讲，这种数据结构令人非常痛苦，所以，上传这块会有三个不同的版本，我一直希望上传可以和具体的业务解耦，即使需要给文件增加备注或者是关联相关信息，应该交给新的Service去做这件事情啊，这简直教人头疼啊。</p><h2 id="可配置与动态化"><a href="#可配置与动态化" class="headerlink" title="可配置与动态化"></a>可配置与动态化</h2><p>  我知道许多人对特性这种<strong>”配置“</strong>方式并不感冒，因为他们觉得通过配置文件就可以做到不修改代码。我曾经帮助组里写了一个非常简洁的配置方案，后来这个方案在Code Review的时候被拒绝，因为我和别人写得不一样。直到前几天我看到ASP.NET Core里全新的配置方式，我瞬间意识到这种配置方式和我之前的想法不谋而合，这个世界上聪明的人的想法总是如此一致。我相信人们看到这篇文章里出现的各种特性，都会认为像Host、URL等等这些东西都被硬编码了，说得好像你们的代码不需要随着配置文件变化而变化似的，说得好像你们的代码每次都不需要重新编译似的。我曾经考虑到这一点，在开发一个库的时候，充分考虑到了可配置化，事实是大家都不喜欢写配置文件，从那以后，我就变成了坚定的<strong>“约定大于配置“</strong>主义。</p><p>  回到WebApiClient这个话题，如果你不喜欢这种基于特性的配置方式，那么你可以通过HttpApiConfig这个类，动态地对诸如Host、URL等参数进行配置，并在WebApiClient创建接口实例的时候传入这些配置。下面是一个简单的示例：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动创建配置</span></span><br><span class="line"><span class="keyword">var</span> config = <span class="keyword">new</span> HttpApiConfig()</span><br><span class="line">{</span><br><span class="line">    HttpHost = <span class="keyword">new</span> Uri(<span class="string">"http://www.yourdomain.com"</span>),</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Values Service</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = HttpApiClient.Create<IValuesApiCaller>(config))</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">"-----Invoke Values Service-----"</span>);</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">await</span> client.GetValues().InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"results is <span class="subst">{results}</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.GetValue(<span class="number">10</span>).InvokeAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">$"result is <span class="subst">{result}</span>"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  我知道杠精们绝对还有话要说，如果我连请求的URL都是动态地该怎么办呢？此时，你总不能让我再让我去配置URL了吧！对于这个问题，WebApiClient提供了Url特性，该特性可以修饰参数，表明这是一个URL，需要注意的是，该参数必须放在第一位，具体可以参考<a href="https://github.com/dotnetcore/WebApiClient/wiki/WebApiClient%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">官方文档</a>。<br></p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function">ITask<<span class="keyword">string</span>> <span class="title">Login</span>(<span class="params">[Url] <span class="keyword">string</span> url, <span class="keyword">string</span> username, <span class="keyword">string</span> password</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>  有时候，我会一直在想，前后端分离到底分离的是什么？在我看来，找出这种界限是最重要的，即前端与后端各自的职责是什么。我们想分离的其实是职责，可惜这种想法极其容易演变为前后端人员的分离。而这种人员上的分离，则让接口的设计和沟通充满了坎坷。前后端分离不在于项目是否由两个或者更多的人完成，而在于你是否可以意识到前后端代码里的界限。在这种前提下，博主通过项目上前后端分离的实践经验，配合产品本身的技术架构体系，引申出一个话题，即<strong>前端/客户端如何应对后端API快速扩增带来的影响</strong>，并由此提出，<strong>通过代理类来调用后端API的想法</strong>，这一想法借鉴了WebService。接下来，我们介绍了.NET平台下的Retrofit：WebApiClient，它可以让我们以一种“契约式”思想来声明接口，而不必关心这个接口该如何去实现，因为WebApiClient会帮助你实现具体功能。更改接口的代价永远比实现接口要小，所以，我相信这种声明式的HTTP客户端，可以让你更快速地应对来自后端的影响。在Java的世界里有Retrofit、有Feign，为了不被超越 太多，我们只能迎头赶上。谢谢大家，本篇到此结束，周末愉快！😬</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="RESTful" scheme="https://qinyuanpei.github.io/tags/RESTful/"/>
    
      <category term="WebApi" scheme="https://qinyuanpei.github.io/tags/WebApi/"/>
    
      <category term="HttpClient" scheme="https://qinyuanpei.github.io/tags/HttpClient/"/>
    
  </entry>
  
</feed>
